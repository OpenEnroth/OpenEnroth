#pragma once

#include <unordered_map>
#include <vector>
#include <utility>
#include <string>

#include "Engine/Data/TileEnums.h"

#include "Library/Image/Image.h"

#include "Utility/Hash.h"
#include "Utility/String/TransparentFunctors.h"

class TileTable;

/**
 * This class populates the tile table and generates tiles for tile transitions that were missing in MM7 data.
 *
 * Actual terrain patching to use the new tiles is done in `OutdoorTerrain::recalculateTransitions`.
 */
class TileGenerator {
 public:
    TileGenerator();
    ~TileGenerator();

    /**
     * Fills the tile table with the new tiles. Be sure to call `ensureTile` for each of the tiles you'll actually use.
     */
    void fillTable();

    /**
     * @param name                      Name of the tile to generate if it doesn't exist yet. Name must come from
     *                                  what was generated by a call to `fillTable`.
     */
    void ensureTile(std::string_view name);

 private:
    RgbaImage generateTile(Tileset tileset, TileVariant variant);
    RgbaImageView loadTile(Tileset tileset, TileVariant variant);
    TileVariant findSpanningVariant(Directions currentDirections, Directions targetDirections) const;
    void blendTile(RgbaImageView base, RgbaImageView dirt, RgbaImageView layer1, RgbaImage *layer0) const;

 private:
    /** All standard transition tiles & their directions. */
    std::vector<std::pair<TileVariant, Directions>> _standardTiles;

    /** Cached images for standard transition tiles. We can't use images from `AssetsManager` because they are
     * desaturation-adjusted. */
    std::unordered_map<std::pair<Tileset, TileVariant>, RgbaImage> _tileByTilesetVariant;

    /** Name to tileset-variant mapping. Used for figuring out at runtime which tile is requested w/o having to parse
     * the name. */
    std::unordered_map<std::string, std::pair<Tileset, TileVariant>, TransparentStringHash, TransparentStringEquals> _tilesetVariantByName;
};

extern TileGenerator *pTileGenerator;
