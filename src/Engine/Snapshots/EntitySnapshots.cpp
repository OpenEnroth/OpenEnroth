#include "EntitySnapshots.h"

#include <algorithm>
#include <string>
#include <unordered_map>

#include "Engine/ArenaEnumFunctions.h"
#include "Engine/Engine.h"
#include "Engine/Graphics/Indoor.h"
#include "Engine/Graphics/Level/Decoration.h"
#include "Engine/Graphics/DecorationList.h"
#include "Engine/Graphics/Outdoor.h"
#include "Engine/Graphics/Overlays.h"
#include "Engine/Graphics/Sprites.h"
#include "Engine/Graphics/TextureFrameTable.h"
#include "Engine/Graphics/Image.h"
#include "Engine/Objects/Actor.h"
#include "Engine/Objects/NPC.h"
#include "Engine/Objects/ObjectList.h"
#include "Engine/Objects/SpriteObject.h"
#include "Engine/Objects/Chest.h"
#include "Engine/Party.h"
#include "Engine/SaveLoad.h"
#include "Engine/Tables/IconFrameTable.h"
#include "Engine/Tables/CharacterFrameTable.h"
#include "Engine/Tables/TileTable.h"
#include "Engine/Time/Time.h"

#include "Media/Audio/SoundInfo.h"

#include "GUI/GUIFont.h"

#include "Library/Color/ColorTable.h"
#include "Library/Snapshots/CommonSnapshots.h"

#include "Utility/Memory/MemSet.h"
#include "Utility/String.h"
#include "Utility/MapAccess.h"

/**
 * Mapping used for beacon map id serialization.
 *
 * DON'T EDIT, THIS IS AUTOGENERATED CODE.
 *
 * @see runBeaconsCodeGen
 */
static const std::unordered_map<MapId, uint16_t> gamesLodIndexByMapId = {
    {MAP_ERATHIAN_SEWERS, 0},
    {MAP_MAZE, 1},
    {MAP_CASTLE_GLOAMING, 2},
    {MAP_TEMPLE_OF_BAA, 3},
    {MAP_ARENA, 4},
    {MAP_TEMPLE_OF_THE_MOON, 5},
    {MAP_THUNDERFIST_MOUNTAIN, 6},
    {MAP_TULAREAN_CAVES, 7},
    {MAP_TITANS_STRONGHOLD, 8},
    {MAP_BREEDING_ZONE, 9},
    {MAP_WALLS_OF_MIST, 10},
    {MAP_CLANKERS_LABORATORY, 11},
    {MAP_ZOKARRS_TOMB, 12},
    {MAP_SCHOOL_OF_SORCERY, 13},
    {MAP_WATCHTOWER_6, 14},
    {MAP_WINE_CELLAR, 15},
    {MAP_TIDEWATER_CAVERNS, 16},
    {MAP_LORD_MARKHAMS_MANOR, 17},
    {MAP_GRAND_TEMPLE_OF_THE_MOON, 18},
    {MAP_MERCENARY_GUILD, 19},
    {MAP_WHITE_CLIFF_CAVE, 20},
    {MAP_HALL_UNDER_THE_HILL, 21},
    {MAP_LINCOLN, 22},
    {MAP_STONE_CITY, 23},
    {MAP_CELESTE, 24},
    {MAP_PIT, 25},
    {MAP_COLONY_ZOD, 26},
    {MAP_DRAGONS_LAIR, 27},
    {MAP_CASTLE_HARMONDALE, 28},
    {MAP_CASTLE_LAMBENT, 29},
    {MAP_FORT_RIVERSTRIDE, 30},
    {MAP_CASTLE_NAVAN, 31},
    {MAP_CASTLE_GRYPHONHEART, 32},
    {MAP_RED_DWARF_MINES, 33},
    {MAP_NIGHON_TUNNELS, 34},
    {MAP_TUNNELS_TO_EEOFOL, 35},
    {MAP_HAUNTED_MANSION, 36},
    {MAP_BARROW_VII, 37},
    {MAP_BARROW_IV, 38},
    {MAP_BARROW_II, 39},
    {MAP_BARROW_XIV, 40},
    {MAP_BARROW_III, 41},
    {MAP_BARROW_X, 42},
    {MAP_BARROW_XII, 43},
    {MAP_BARROW_V, 44},
    {MAP_BARROW_XI, 45},
    {MAP_BARROW_XV, 46},
    {MAP_BARROW_IX, 47},
    {MAP_BARROW_VI, 48},
    {MAP_BARROW_I, 49},
    {MAP_BARROW_VIII, 50},
    {MAP_BARROW_XIII, 51},
    {MAP_WROMTHRAXS_CAVE, 52},
    {MAP_WILLIAM_SETAGS_TOWER, 53},
    {MAP_HIDDEN_TOMB, 54},
    {MAP_DRAGON_CAVES, 55},
    {MAP_BANDIT_CAVES, 56},
    {MAP_SMALL_HOUSE, 57},
    {MAP_STRANGE_TEMPLE, 58},
    {MAP_EMERALD_ISLAND, 59},
    {MAP_HARMONDALE, 60},
    {MAP_ERATHIA, 61},
    {MAP_TULAREAN_FOREST, 62},
    {MAP_DEYJA, 63},
    {MAP_BRACADA_DESERT, 64},
    {MAP_EVENMORN_ISLAND, 65},
    {MAP_MOUNT_NIGHON, 66},
    {MAP_BARROW_DOWNS, 67},
    {MAP_LAND_OF_THE_GIANTS, 68},
    {MAP_TATALIA, 69},
    {MAP_AVLEE, 70},
    {MAP_SHOALS, 71},
    {MAP_TEMPLE_OF_THE_LIGHT, 72},
    {MAP_TEMPLE_OF_THE_DARK, 73},
    {MAP_GRAND_TEMPLE_OF_THE_SUN, 74},
    {MAP_HALL_OF_THE_PIT, 75},
};
static const std::unordered_map<uint16_t, MapId> mapIdByGamesLodIndex = inverted(gamesLodIndexByMapId);

static void snapshot(const Time &src, int64_t *dst) {
    *dst = src.ticks();
}

static void reconstruct(int64_t src, Time *dst) {
    *dst = Time::fromTicks(src);
}

static void snapshot(const Duration &src, int32_t *dst) {
    *dst = src.ticks();
}

static void reconstruct(int32_t src, Duration *dst) {
    *dst = Duration::fromTicks(src);
}

static void snapshot(const CombinedSkillValue &src, uint16_t *dst) {
    *dst = src.joined();
}

static void reconstruct(const uint16_t &src, CombinedSkillValue *dst) {
    *dst = CombinedSkillValue::fromJoined(src);
}

static void snapshot(const MonsterId &src, int16_t *dst) {
    *dst = std::to_underlying(src);
}

static void reconstruct(int16_t src, MonsterId *dst) {
    *dst = static_cast<MonsterId>(src);
}

void snapshot(const Pid &src, uint16_t *dst) {
    *dst = src.packed();
}

void reconstruct(uint16_t src, Pid *dst) {
    *dst = Pid::fromPacked(src);
}

void snapshot(const Vec3i &src, Vec3s *dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void reconstruct(const Vec3s &src, Vec3i *dst) {
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void snapshot(const Vec3f& src, Vec3s* dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void reconstruct(const Vec3s& src, Vec3f* dst) {
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void snapshot(const BBoxi &src, BBoxs_MM7 *dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x1 = src.x1;
    dst->x2 = src.x2;
    dst->y1 = src.y1;
    dst->y2 = src.y2;
    dst->z1 = src.z1;
    dst->z2 = src.z2;
}

void reconstruct(const BBoxs_MM7 &src, BBoxi *dst) {
    dst->x1 = src.x1;
    dst->x2 = src.x2;
    dst->y1 = src.y1;
    dst->y2 = src.y2;
    dst->z1 = src.z1;
    dst->z2 = src.z2;
}

void reconstruct(const Planef_MM7 &src, Planef *dst) {
    dst->normal = src.normal;
    dst->dist = src.dist;
}

void reconstruct(const Planei_MM7 &src, Planef *dst) {
    dst->normal.x = src.normal.x / 65536.0f;
    dst->normal.y = src.normal.y / 65536.0f;
    dst->normal.z = src.normal.z / 65536.0f;
    dst->dist = src.dist / 65536.0f;
}

void reconstruct(const SpriteFrame_MM7 &src, SpriteFrame *dst) {
    reconstruct(src.iconName, &dst->icon_name);
    dst->icon_name = toLower(dst->icon_name);

    reconstruct(src.textureName, &dst->texture_name);
    dst->texture_name = toLower(dst->texture_name);

    for (unsigned int i = 0; i < 8; ++i)
        dst->hw_sprites[i] = nullptr;

    dst->scale = src.scale / 65536.0f;
    dst->uFlags = src.flags;

    dst->uGlowRadius = src.glowRadius;
    dst->uPaletteID = src.paletteId;
    dst->ResetPaletteIndex(src.paletteIndex);
    dst->uAnimTime = Duration::fromTicks(src.animTime * 8);
    dst->uAnimLength = Duration::fromTicks(src.animLength * 8);
}

void reconstruct(const BLVFace_MM7 &src, BLVFace *dst) {
    reconstruct(src.facePlane, &dst->facePlane);
    dst->zCalc.init(dst->facePlane);
    dst->uAttributes = static_cast<FaceAttributes>(src.attributes);
    dst->pVertexIDs = nullptr;
    dst->pVertexUIDs = nullptr;
    dst->pVertexVIDs = nullptr;
    dst->uFaceExtraID = src.faceExtraId;
    dst->resource = nullptr;
    dst->uSectorID = src.sectorId;
    dst->uBackSectorID = src.backSectorId;
    reconstruct(src.bounding, &dst->pBounding);
    dst->uPolygonType = static_cast<PolygonType>(src.polygonType);
    dst->uNumVertices = src.numVertices;
}

void reconstruct(const TileDesc_MM7 &src, TileDesc *dst) {
    reconstruct(src.tileName, &dst->name);
    dst->name = toLower(dst->name);

    if (istarts_with(dst->name, "wtrdr"))
        dst->name.insert(0, "h");  // mm7 uses hd water tiles with legacy names

    dst->uTileID = src.tileId;
    dst->tileset = static_cast<Tileset>(src.tileSet);
    dst->uSection = static_cast<TILE_SECT>(src.section);
    dst->uAttributes = static_cast<TILE_DESC_FLAGS>(src.attributes);
}

void reconstruct(const TextureFrame_MM7 &src, TextureFrame *dst) {
    reconstruct(src.textureName, &dst->name);
    dst->name = toLower(dst->name);

    dst->animationDuration = Duration::fromTicks(src.animLength * 8);
    dst->frameDuration = Duration::fromTicks(src.animTime * 8);
    dst->flags = static_cast<TextureFrameFlags>(src.flags);
}

void snapshot(const RawTimer &src, Timer_MM7 *dst) {
    memzero(dst);

    dst->ready = true;
    dst->paused = src._paused;
    dst->turnBased = src._turnBased;
    dst->lastFrameTime = src._lastFrameTime.ticks();
    dst->pauseTime = 0;
    dst->turnBasedTime = 0;
    dst->timeElapsed = src._dt.ticks();
    dst->dtFixpoint = src._dt.toFloatRealtimeSeconds() * 65536.0f;
    dst->totalGameTimeElapsed = src._time.ticks();
}

void reconstruct(const Timer_MM7 &src, RawTimer *dst) {
    dst->_paused = src.paused;
    dst->_turnBased = src.turnBased;
    dst->_lastFrameTime = Duration::fromTicks(src.lastFrameTime);
    dst->_dt = Duration::fromTicks(src.timeElapsed);
    dst->_time = Duration::fromTicks(src.totalGameTimeElapsed);
}

void snapshot(const NPCData &src, NPCData_MM7 *dst) {
    memzero(dst);

    dst->name = !src.name.empty();
    dst->portraitId = src.uPortraitID;
    dst->flags = std::to_underlying(src.uFlags);
    dst->fame = src.fame;
    dst->rep = src.rep;
    dst->location2d = std::to_underlying(src.Location2D);
    dst->profession = std::to_underlying(src.profession);
    dst->greet = src.greet;
    dst->joins = src.is_joinable;
    dst->field_24 = src.field_24;
    dst->evt_A = src.dialogue_1_evt_id;
    dst->evt_B = src.dialogue_2_evt_id;
    dst->evt_C = src.dialogue_3_evt_id;
    dst->evt_D = src.dialogue_4_evt_id;
    dst->evt_E = src.dialogue_5_evt_id;
    dst->evt_F = src.dialogue_6_evt_id;
    dst->sex = std::to_underlying(src.uSex);
    dst->hasUsedAbility = src.bHasUsedTheAbility;
    dst->newsTopic = src.news_topic;
}

void reconstruct(const NPCData_MM7 &src, NPCData *dst) {
    dst->name = src.name ? "Dummy" : "";
    dst->uPortraitID = src.portraitId;
    dst->uFlags = NpcFlags(src.flags);
    dst->fame = src.fame;
    dst->rep = src.rep;
    dst->Location2D = static_cast<HouseId>(src.location2d);
    dst->profession = static_cast<NpcProfession>(src.profession);
    dst->greet = src.greet;
    dst->is_joinable = src.joins;
    dst->field_24 = src.field_24;
    dst->dialogue_1_evt_id = src.evt_A;
    dst->dialogue_2_evt_id = src.evt_B;
    dst->dialogue_3_evt_id = src.evt_C;
    dst->dialogue_4_evt_id = src.evt_D;
    dst->dialogue_5_evt_id = src.evt_E;
    dst->dialogue_6_evt_id = src.evt_F;
    dst->uSex = static_cast<CharacterSex>(src.sex);
    dst->bHasUsedTheAbility = src.hasUsedAbility;
    dst->news_topic = src.newsTopic;
}

void snapshot(const ActiveOverlay &src, ActiveOverlay_MM7 *dst) {
    memzero(dst);

    dst->indexToOverlayList = src.indexToOverlayList;
    dst->spriteFrameTime = src.spriteFrameTime;
    dst->animLength = src.animLength;
    dst->screenSpaceX = src.screenSpaceX;
    dst->screenSpaceY = src.screenSpaceY;
    dst->pid = src.pid.packed();
    dst->projSize = src.projSize;
    dst->fpDamageMod = src.fpDamageMod;
}

void reconstruct(const ActiveOverlay_MM7 &src, ActiveOverlay *dst) {
    memzero(dst);

    dst->indexToOverlayList = src.indexToOverlayList;
    dst->spriteFrameTime = src.spriteFrameTime;
    dst->animLength = src.animLength;
    dst->screenSpaceX = src.screenSpaceX;
    dst->screenSpaceY = src.screenSpaceY;
    dst->pid = Pid::fromPacked(src.pid);
    dst->projSize = src.projSize;
    dst->fpDamageMod = src.fpDamageMod;
}

void snapshot(const ActiveOverlayList &src, ActiveOverlayList_MM7 *dst) {
    memzero(dst);

    dst->redraw = true;
    snapshot(src.pOverlays, &dst->overlays);
}

void reconstruct(const ActiveOverlayList_MM7 &src, ActiveOverlayList *dst) {
    reconstruct(src.overlays, &dst->pOverlays);
}

void snapshot(const SpellBuff &src, SpellBuff_MM7 *dst) {
    memzero(dst);

    snapshot(src.expireTime, &dst->expireTime);
    dst->power = src.power;
    dst->skillMastery = std::to_underlying(src.skillMastery);
    dst->overlayId = src.overlayID;
    dst->caster = src.caster;
    dst->flags = src.isGMBuff;
}

void reconstruct(const SpellBuff_MM7 &src, SpellBuff *dst) {
    reconstruct(src.expireTime, &dst->expireTime);
    dst->power = src.power;
    dst->skillMastery = static_cast<CharacterSkillMastery>(src.skillMastery);
    dst->overlayID = src.overlayId;
    dst->caster = src.caster;
    dst->isGMBuff = src.flags;
}

void snapshot(const ItemGen &src, ItemGen_MM7 *dst) {
    memzero(dst);

    dst->itemID = std::to_underlying(src.uItemID);
    if (isPotion(src.uItemID)) {
        dst->attributeEnchantmentOrPotionPower = src.potionPower;
    } else if (src.attributeEnchantment) {
        dst->attributeEnchantmentOrPotionPower = std::to_underlying(*src.attributeEnchantment) + 1;
    } else {
        dst->attributeEnchantmentOrPotionPower = 0;
    }
    dst->enchantmentStrength = src.m_enchantmentStrength;
    if (isGold(src.uItemID)) {
        dst->specialEnchantmentOrGoldAmount = src.goldAmount;
    } else {
        dst->specialEnchantmentOrGoldAmount = std::to_underlying(src.special_enchantment);
    }
    dst->numCharges = src.uNumCharges;
    dst->attributes = std::to_underlying(src.uAttributes);
    dst->bodyAnchor = std::to_underlying(src.uBodyAnchor);
    dst->maxCharges = src.uMaxCharges;
    dst->holderPlayer = src.uHolderPlayer;
    dst->placedInChest = src.placedInChest;
    snapshot(src.uExpireTime, &dst->expireTime);
}

void reconstruct(const ItemGen_MM7 &src, ItemGen *dst) {
    dst->uItemID = static_cast<ItemId>(src.itemID);
    if (isPotion(dst->uItemID)) {
        dst->potionPower = src.attributeEnchantmentOrPotionPower;
        dst->attributeEnchantment = {};
    } else if (src.attributeEnchantmentOrPotionPower) {
        dst->potionPower = 0;
        dst->attributeEnchantment = static_cast<CharacterAttributeType>(src.attributeEnchantmentOrPotionPower - 1);
    } else {
        dst->potionPower = 0;
        dst->attributeEnchantment = {};
    }
    dst->m_enchantmentStrength = src.enchantmentStrength;
    if (isGold(dst->uItemID)) {
        dst->goldAmount = src.specialEnchantmentOrGoldAmount;
        dst->special_enchantment = ITEM_ENCHANTMENT_NULL;
    } else {
        dst->goldAmount = 0;
        dst->special_enchantment = static_cast<ItemEnchantment>(src.specialEnchantmentOrGoldAmount);
    }
    dst->uNumCharges = src.numCharges;
    dst->uAttributes = ItemFlags(src.attributes);
    dst->uBodyAnchor = static_cast<ItemSlot>(src.bodyAnchor);
    dst->uMaxCharges = src.maxCharges;
    dst->uHolderPlayer = src.holderPlayer;
    dst->placedInChest = src.placedInChest;
    reconstruct(src.expireTime, &dst->uExpireTime);
}

void snapshot(const Party &src, Party_MM7 *dst) {
    memzero(dst);

    dst->field_0 = 25; // Vanilla set this to 25, so we're doing the same just in case.
    dst->partyHeight = src.height;
    dst->defaultPartyHeight = src.height;
    dst->eyeLevel = src.eyeLevel;
    dst->defaultEyeLevel = src.eyeLevel;
    dst->radius = src.radius;
    dst->yawGranularity = src._yawGranularity;
    dst->walkSpeed = src.walkSpeed;
    dst->yawRotationSpeed = src._yawRotationSpeed;
    dst->jumpStrength = src.jump_strength;
    snapshot(src.playing_time, &dst->timePlayed);
    snapshot(src.last_regenerated, &dst->lastRegenerationTime);

    snapshot(src.PartyTimes.bountyHuntNextGenTime, &dst->partyTimes.bountyHuntingNextGenerationTime);
    dst->partyTimes.bountyHuntingNextGenerationTimeUnused.fill(0);

    // Initially was one array but was splitted in two to simplify access with first element as zero
    // because it is corresponding to invalid house ID
    dst->partyTimes.shopsNextGenerationTime0 = 0;
    snapshot(src.PartyTimes.shopNextRefreshTime, &dst->partyTimes.shopsNextGenerationTime);
    snapshot(src.PartyTimes.guildNextRefreshTime, &dst->partyTimes.guildsNextGenerationTime);

    dst->partyTimes.shopBanTime0 = 0;
    snapshot(src.PartyTimes.shopBanTimes, &dst->partyTimes.shopBanTimes);
    snapshot(src.PartyTimes.CounterEventValues, &dst->partyTimes.counterEventValues);
    snapshot(src.PartyTimes.HistoryEventTimes, &dst->partyTimes.historyEventTimes);
    snapshot(src.PartyTimes._s_times, &dst->partyTimes.someOtherTimes);

    dst->position = src.pos.toInt();
    dst->viewYaw = src._viewYaw;
    dst->viewPitch = src._viewPitch;
    dst->prevPosition = src.lastPos.toInt();
    dst->viewPrevYaw = src._viewPrevYaw;
    dst->viewPrevPitch = src._viewPrevPitch;
    dst->prevEyeLevel = src.lastEyeLevel;
    dst->fallSpeed = src.velocity.z;
    dst->savedFlightZ = src.sPartySavedFlightZ;
    dst->waterLavaTimer = src._6FC_water_lava_timer.ticks(); // Can overflow and that's OK.
    dst->fallStartZ = src.uFallStartZ;
    dst->flying = src.bFlying;
    dst->field_708 = 15; // Vanilla set this to 15, so we're doing the same just in case.
    dst->hirelingScrollPosition = src.hirelingScrollPosition;
    dst->field_70A = src.cNonHireFollowers;
    dst->currentYear = src.uCurrentYear;
    dst->currentMonth = src.uCurrentMonth;
    dst->currentMonthWeek = src.uCurrentMonthWeek;
    dst->currentDayOfMonth = src.uCurrentDayOfMonth;
    dst->currentHour = src.uCurrentHour;
    dst->currentMinute = src.uCurrentMinute;
    dst->currentTimeSecond = src.uCurrentTimeSecond;
    dst->numFoodRations = src.GetFood();
    dst->numGold = src.GetGold();
    dst->numGoldInBank = src.uNumGoldInBank;
    dst->numDeaths = src.uNumDeaths;
    dst->numPrisonTerms = src.uNumPrisonTerms;
    dst->numBountiesCollected = src.uNumBountiesCollected;

    snapshot(src.monster_id_for_hunting, &dst->monsterIdForHunting);
    snapshot(src.monster_for_hunting_killed, &dst->monsterForHuntingKilled, tags::cast<bool, int16_t>);

    dst->daysPlayedWithoutRest = src.days_played_without_rest;

    snapshot(src._questBits, &dst->questBits, tags::reverseBits);
    snapshot(src.pArcomageWins, &dst->arcomageWins);

    // We can't save in arena, but doing proper serialization here anyway.
    if (src.arenaState == ARENA_STATE_INITIAL) {
        dst->field_7B5_in_arena_quest = 0;
    } else if (src.arenaState == ARENA_STATE_WON) {
        dst->field_7B5_in_arena_quest = -1;
    } else  {
        dst->field_7B5_in_arena_quest = std::to_underlying(dialogueForArenaLevel(src.arenaLevel));
    }

    snapshot(src.uNumArenaWins, &dst->numArenaWins);

    snapshot(src.pIsArtifactFound, &dst->isArtifactFound);
    snapshot(src._autonoteBits, &dst->autonoteBits, tags::reverseBits);

    dst->numArcomageWins = src.uNumArcomageWins;
    dst->numArcomageLoses = src.uNumArcomageLoses;
    dst->turnBasedModeOn = src.bTurnBasedModeOn;
    dst->flags2 = std::to_underlying(src.uFlags2);

    unsigned align = 0;
    if (src.alignment == PartyAlignment::PartyAlignment_Evil) align = 2;
    if (src.alignment == PartyAlignment::PartyAlignment_Neutral) align = 1;
    dst->alignment = align;

    snapshot(src.pPartyBuffs, &dst->partyBuffs);
    snapshot(src.pCharacters, &dst->players);
    snapshot(src.pHirelings, &dst->hirelings);

    // Vanilla stored NPC sacrifice status in NPC evt values.
    for (int i = 0; i < 2; i++) {
        if (src.pHirelingsSacrifice[i].inProgress) {
            dst->hirelings[i].evt_A = 1;
            dst->hirelings[i].evt_B = src.pHirelingsSacrifice[i].elapsedTime.ticks();
            dst->hirelings[i].evt_C = src.pHirelingsSacrifice[i].endTime.ticks();
        }
    }

    snapshot(src.pPickedItem, &dst->pickedItem);

    dst->flags = std::to_underlying(src.uFlags);

    dst->standartItemsInShop0.fill({});
    snapshot(src.standartItemsInShops, &dst->standartItemsInShops);
    dst->specialItemsInShop0.fill({});
    snapshot(src.specialItemsInShops, &dst->specialItemsInShops);
    snapshot(src.spellBooksInGuilds, &dst->spellBooksInGuilds);

    snapshot(src.pHireling1Name, &dst->hireling1Name);
    snapshot(src.pHireling2Name, &dst->hireling2Name);

    dst->armageddonTimer = src.armageddon_timer.ticks();
    dst->armageddonDamage = src.armageddonDamage;

    snapshot(src.pTurnBasedCharacterRecoveryTimes, &dst->turnBasedPlayerRecoveryTimes);
    snapshot(src.InTheShopFlags, &dst->inTheShopFlags);

    dst->fine = src.uFine;
}

void reconstruct(const Party_MM7 &src, Party *dst) {
    dst->Zero();

    dst->height = src.partyHeight;
    dst->eyeLevel = src.eyeLevel;
    dst->radius = src.radius;
    dst->_yawGranularity = src.yawGranularity;
    dst->walkSpeed = src.walkSpeed;
    dst->_yawRotationSpeed = src.yawRotationSpeed;
    dst->jump_strength = src.jumpStrength;
    reconstruct(src.timePlayed, &dst->playing_time);
    reconstruct(src.lastRegenerationTime, &dst->last_regenerated);

    reconstruct(src.partyTimes.bountyHuntingNextGenerationTime, &dst->PartyTimes.bountyHuntNextGenTime);
    reconstruct(src.partyTimes.shopsNextGenerationTime, &dst->PartyTimes.shopNextRefreshTime);
    reconstruct(src.partyTimes.guildsNextGenerationTime, &dst->PartyTimes.guildNextRefreshTime);
    reconstruct(src.partyTimes.shopBanTimes, &dst->PartyTimes.shopBanTimes);
    reconstruct(src.partyTimes.counterEventValues, &dst->PartyTimes.CounterEventValues);
    reconstruct(src.partyTimes.historyEventTimes, &dst->PartyTimes.HistoryEventTimes);
    reconstruct(src.partyTimes.someOtherTimes, &dst->PartyTimes._s_times);

    dst->pos = src.position.toFloat();
    dst->_viewYaw = src.viewYaw;
    dst->_viewPitch = src.viewPitch;
    dst->lastPos = src.prevPosition.toFloat();
    dst->_viewPrevYaw = src.viewPrevYaw;
    dst->_viewPrevPitch = src.viewPrevPitch;
    dst->lastEyeLevel = src.prevEyeLevel;
    dst->velocity = Vec3f(0, 0, src.fallSpeed);
    dst->sPartySavedFlightZ = src.savedFlightZ;
    dst->_6FC_water_lava_timer = Time::fromTicks(src.waterLavaTimer);
    dst->uFallStartZ = src.fallStartZ;
    dst->bFlying = src.flying;
    dst->hirelingScrollPosition = src.hirelingScrollPosition;
    dst->cNonHireFollowers = src.field_70A;
    dst->uCurrentYear = src.currentYear;
    dst->uCurrentMonth = src.currentMonth;
    dst->uCurrentMonthWeek = src.currentMonthWeek;
    dst->uCurrentDayOfMonth = src.currentDayOfMonth;
    dst->uCurrentHour = src.currentHour;
    dst->uCurrentMinute = src.currentMinute;
    dst->uCurrentTimeSecond = src.currentTimeSecond;
    dst->uNumFoodRations = src.numFoodRations;
    dst->uNumGold = src.numGold;
    dst->uNumGoldInBank = src.numGoldInBank;
    dst->uNumDeaths = src.numDeaths;
    dst->uNumPrisonTerms = src.numPrisonTerms;
    dst->uNumBountiesCollected = src.numBountiesCollected;

    reconstruct(src.monsterIdForHunting, &dst->monster_id_for_hunting);
    reconstruct(src.monsterForHuntingKilled, &dst->monster_for_hunting_killed, tags::cast<int16_t, bool>);

    dst->days_played_without_rest = src.daysPlayedWithoutRest;

    reconstruct(src.questBits, &dst->_questBits, tags::reverseBits);
    reconstruct(src.arcomageWins, &dst->pArcomageWins);

    // We can't save in arena, but doing proper deserialization here anyway.
    if (src.field_7B5_in_arena_quest == 0) {
        dst->arenaState = ARENA_STATE_INITIAL;
        dst->arenaLevel = ARENA_LEVEL_INVALID;
    } else if (src.field_7B5_in_arena_quest == -1) {
        dst->arenaState = ARENA_STATE_WON;
        dst->arenaLevel = ARENA_LEVEL_INVALID;
    } else  {
        dst->arenaState = ARENA_STATE_FIGHTING;
        dst->arenaLevel = arenaLevelForDialogue(static_cast<DialogueId>(src.field_7B5_in_arena_quest));
    }

    reconstruct(src.numArenaWins, &dst->uNumArenaWins);

    reconstruct(src.isArtifactFound, &dst->pIsArtifactFound);
    reconstruct(src.autonoteBits, &dst->_autonoteBits, tags::reverseBits);

    dst->uNumArcomageWins = src.numArcomageWins;
    dst->uNumArcomageLoses = src.numArcomageLoses;
    dst->bTurnBasedModeOn = src.turnBasedModeOn;
    dst->uFlags2 = static_cast<PARTY_FLAGS_2>(src.flags2);

    switch (src.alignment) {
        case 0:
            dst->alignment = PartyAlignment::PartyAlignment_Good;
            break;
        case 1:
            dst->alignment = PartyAlignment::PartyAlignment_Neutral;
            break;
        case 2:
            dst->alignment = PartyAlignment::PartyAlignment_Evil;
            break;
        default:
            assert(false);
    }

    reconstruct(src.partyBuffs, &dst->pPartyBuffs);
    reconstruct(src.players, &dst->pCharacters);
    reconstruct(src.hirelings, &dst->pHirelings);

    // Vanilla stored NPC sacrifice status in NPC evt values.
    for (int i = 0; i < 2; i++) {
        if (src.hirelings[i].evt_A) {
            dst->pHirelings[i].dialogue_1_evt_id = 0;
            dst->pHirelings[i].dialogue_2_evt_id = 0;
            dst->pHirelings[i].dialogue_3_evt_id = 0;
            dst->pHirelingsSacrifice[i].inProgress = true;
            dst->pHirelingsSacrifice[i].elapsedTime = Duration::fromTicks(src.hirelings[i].evt_B);
            dst->pHirelingsSacrifice[i].endTime = Duration::fromTicks(src.hirelings[i].evt_C);
        }
    }

    reconstruct(src.pickedItem, &dst->pPickedItem);

    dst->uFlags = static_cast<PartyFlags>(src.flags);

    reconstruct(src.standartItemsInShops, &dst->standartItemsInShops);
    reconstruct(src.specialItemsInShops, &dst->specialItemsInShops);
    reconstruct(src.spellBooksInGuilds, &dst->spellBooksInGuilds);

    reconstruct(src.hireling1Name, &dst->pHireling1Name);
    reconstruct(src.hireling2Name, &dst->pHireling2Name);

    dst->armageddon_timer = Duration::fromTicks(src.armageddonTimer);
    dst->armageddonDamage = src.armageddonDamage;

    reconstruct(src.turnBasedPlayerRecoveryTimes, &dst->pTurnBasedCharacterRecoveryTimes);
    reconstruct(src.inTheShopFlags, &dst->InTheShopFlags);

    dst->uFine = src.fine;
}

void snapshot(const RawCharacterConditions &src, CharacterConditions_MM7 *dst) {
    memzero(dst);

    snapshot(src._times, &dst->times);
}

void reconstruct(const CharacterConditions_MM7 &src, RawCharacterConditions *dst) {
    reconstruct(src.times, &dst->_times);
}

void snapshot(const Character &src, Player_MM7 *dst) {
    memzero(dst);

    snapshot(src.conditions, &dst->conditions);

    dst->experience = src.experience;

    snapshot(src.name, &dst->name);

    dst->sex = std::to_underlying(src.uSex);
    dst->classType = std::to_underlying(src.classType);
    dst->currentFace = src.uCurrentFace;
    dst->might = src.uMight;
    dst->mightBonus = src.uMightBonus;
    dst->intelligence = src.uIntelligence;
    dst->intelligenceBonus = src.uIntelligenceBonus;
    dst->personality = src.uPersonality;
    dst->personalityBonus = src.uPersonalityBonus;
    dst->endurance = src.uEndurance;
    dst->enduranceBonus = src.uEnduranceBonus;
    dst->speed = src.uSpeed;
    dst->speedBonus = src.uSpeedBonus;
    dst->accuracy = src.uAccuracy;
    dst->accuracyBonus = src.uAccuracyBonus;
    dst->luck = src.uLuck;
    dst->luckBonus = src.uLuckBonus;
    dst->acModifier = src.sACModifier;
    dst->level = src.uLevel;
    dst->levelModifier = src.sLevelModifier;
    dst->ageModifier = src.sAgeModifier;

    snapshot(src.pActiveSkills, &dst->activeSkills, tags::segment<CHARACTER_SKILL_FIRST_VISIBLE, CHARACTER_SKILL_LAST_VISIBLE>);
    snapshot(src._achievedAwardsBits, &dst->achievedAwardsBits, tags::reverseBits);
    snapshot(src.bHaveSpell, &dst->haveSpell);

    dst->pureLuckUsed = src.pure_luck_used;
    dst->pureSpeedUsed = src.pure_speed_used;
    dst->pureIntellectUsed = src.pure_intellect_used;
    dst->pureEnduranceUsed = src.pure_endurance_used;
    dst->purePersonalityUsed = src.pure_personality_used;
    dst->pureAccuracyUsed = src.pure_accuracy_used;
    dst->pureMightUsed = src.pure_might_used;

    snapshot(src.pInventoryItemList, &dst->inventoryItems);
    snapshot(src.pInventoryMatrix, &dst->inventoryMatrix);

    dst->resFireBase = src.sResFireBase;
    dst->resAirBase = src.sResAirBase;
    dst->resWaterBase = src.sResWaterBase;
    dst->resEarthBase = src.sResEarthBase;
    dst->resPhysicalBase = src.sResPhysicalBase;
    dst->resMagicBase = src.sResMagicBase;
    dst->resSpiritBase = src.sResSpiritBase;
    dst->resMindBase = src.sResMindBase;
    dst->resBodyBase = src.sResBodyBase;
    dst->resLightBase = src.sResLightBase;
    dst->resDarkBase = src.sResDarkBase;
    dst->resFireBonus = src.sResFireBonus;
    dst->resAirBonus = src.sResAirBonus;
    dst->resWaterBonus = src.sResWaterBonus;
    dst->resEarthBonus = src.sResEarthBonus;
    dst->resPhysicalBonus = src.sResPhysicalBonus;
    dst->resMagicBonus = src.sResMagicBonus;
    dst->resSpiritBonus = src.sResSpiritBonus;
    dst->resMindBonus = src.sResMindBonus;
    dst->resBodyBonus = src.sResBodyBonus;
    dst->resLightBonus = src.sResLightBonus;
    dst->resDarkBonus = src.sResDarkBonus;

    snapshot(src.pCharacterBuffs, &dst->playerBuffs);

    dst->voiceId = src.uVoiceID;
    dst->prevVoiceId = src.uPrevVoiceID;
    dst->prevFace = src.uPrevFace;
    dst->timeToRecovery = src.timeToRecovery.ticks();
    dst->skillPoints = src.uSkillPoints;
    dst->health = src.health;
    dst->mana = src.mana;
    dst->birthYear = src.uBirthYear;

    snapshot(src.pEquipment, &dst->equipment);

    dst->lastOpenedSpellbookPage = std::to_underlying(src.lastOpenedSpellbookPage);
    dst->quickSpell = std::to_underlying(src.uQuickSpell);

    snapshot(src._characterEventBits, &dst->playerEventBits, tags::reverseBits);

    dst->someAttackBonus = src._some_attack_bonus;
    dst->meleeDmgBonus = src._melee_dmg_bonus;
    dst->rangedAttackBonus = src._ranged_atk_bonus;
    dst->rangedDmgBonus = src._ranged_dmg_bonus;
    dst->fullHealthBonus = src.uFullHealthBonus;
    dst->healthRelated = src._health_related;
    dst->fullManaBonus = src.uFullManaBonus;
    dst->manaRelated = src._mana_related;
    dst->expression = std::to_underlying(src.expression);
    dst->expressionTimePassed = src.uExpressionTimePassed.ticks();
    dst->expressionTimeLength = src.uExpressionTimeLength.ticks();
    dst->field_1AA2 = src.uExpressionImageIndex;
    dst->_expression21_animtime = src._expression21_animtime.ticks();
    dst->_expression21_frameset = src._expression21_frameset;

    for (unsigned int i = 0; i < 5; ++i) {
        if (i >= src.vBeacons.size()) {
            continue;
        }
        snapshot(src.vBeacons[i].uBeaconTime, &dst->installedBeacons[i].beaconTime);
        dst->installedBeacons[i].partyPosX = src.vBeacons[i]._partyPos.x;
        dst->installedBeacons[i].partyPosY = src.vBeacons[i]._partyPos.y;
        dst->installedBeacons[i].partyPosZ = src.vBeacons[i]._partyPos.z;
        dst->installedBeacons[i].partyViewYaw = src.vBeacons[i]._partyViewYaw;
        dst->installedBeacons[i].partyViewPitch = src.vBeacons[i]._partyViewPitch;
        dst->installedBeacons[i].mapIndexInGamesLod = valueOr(gamesLodIndexByMapId, src.vBeacons[i].mapId, -1);
    }

    dst->numDivineInterventionCasts = src.uNumDivineInterventionCastsThisDay;
    dst->numArmageddonCasts = src.uNumArmageddonCasts;
    dst->numFireSpikeCasts = src.uNumFireSpikeCasts;
}

void reconstruct(const Player_MM7 &src, Character *dst) {
    dst->Zero();
    reconstruct(src.conditions, &dst->conditions);

    dst->experience = src.experience;

    reconstruct(src.name, &dst->name);

    switch (src.sex) {
    case 0:
        dst->uSex = SEX_MALE;
        break;
    case 1:
        dst->uSex = SEX_FEMALE;
        break;
    default:
        assert(false);
    }

    switch (src.classType) {
    case 0:
        dst->classType = CLASS_KNIGHT;
        break;
    case 1:
        dst->classType = CLASS_CAVALIER;
        break;
    case 2:
        dst->classType = CLASS_CHAMPION;
        break;
    case 3:
        dst->classType = CLASS_BLACK_KNIGHT;
        break;
    case 4:
        dst->classType = CLASS_THIEF;
        break;
    case 5:
        dst->classType = CLASS_ROGUE;
        break;
    case 6:
        dst->classType = CLASS_SPY;
        break;
    case 7:
        dst->classType = CLASS_ASSASSIN;
        break;
    case 8:
        dst->classType = CLASS_MONK;
        break;
    case 9:
        dst->classType = CLASS_INITIATE;
        break;
    case 10:
        dst->classType = CLASS_MASTER;
        break;
    case 11:
        dst->classType = CLASS_NINJA;
        break;
    case 12:
        dst->classType = CLASS_PALADIN;
        break;
    case 13:
        dst->classType = CLASS_CRUSADER;
        break;
    case 14:
        dst->classType = CLASS_HERO;
        break;
    case 15:
        dst->classType = CLASS_VILLIAN;
        break;
    case 16:
        dst->classType = CLASS_ARCHER;
        break;
    case 17:
        dst->classType = CLASS_WARRIOR_MAGE;
        break;
    case 18:
        dst->classType = CLASS_MASTER_ARCHER;
        break;
    case 19:
        dst->classType = CLASS_SNIPER;
        break;
    case 20:
        dst->classType = CLASS_RANGER;
        break;
    case 21:
        dst->classType = CLASS_HUNTER;
        break;
    case 22:
        dst->classType = CLASS_RANGER_LORD;
        break;
    case 23:
        dst->classType = CLASS_BOUNTY_HUNTER;
        break;
    case 24:
        dst->classType = CLASS_CLERIC;
        break;
    case 25:
        dst->classType = CLASS_PRIEST;
        break;
    case 26:
        dst->classType = CLASS_PRIEST_OF_SUN;
        break;
    case 27:
        dst->classType = CLASS_PRIEST_OF_MOON;
        break;
    case 28:
        dst->classType = CLASS_DRUID;
        break;
    case 29:
        dst->classType = CLASS_GREAT_DRUID;
        break;
    case 30:
        dst->classType = CLASS_ARCH_DRUID;
        break;
    case 31:
        dst->classType = CLASS_WARLOCK;
        break;
    case 32:
        dst->classType = CLASS_SORCERER;
        break;
    case 33:
        dst->classType = CLASS_WIZARD;
        break;
    case 34:
        dst->classType = CLASS_ARCHAMGE;
        break;
    case 35:
        dst->classType = CLASS_LICH;
        break;
    default:
        assert(false);
    }

    dst->uCurrentFace = src.currentFace;
    dst->uMight = src.might;
    dst->uMightBonus = src.mightBonus;
    dst->uIntelligence = src.intelligence;
    dst->uIntelligenceBonus = src.intelligenceBonus;
    dst->uPersonality = src.personality;
    dst->uPersonalityBonus = src.personalityBonus;
    dst->uEndurance = src.endurance;
    dst->uEnduranceBonus = src.enduranceBonus;
    dst->uSpeed = src.speed;
    dst->uSpeedBonus = src.speedBonus;
    dst->uAccuracy = src.accuracy;
    dst->uAccuracyBonus = src.accuracyBonus;
    dst->uLuck = src.luck;
    dst->uLuckBonus = src.luckBonus;
    dst->sACModifier = src.acModifier;
    dst->uLevel = src.level;
    dst->sLevelModifier = src.levelModifier;
    dst->sAgeModifier = src.ageModifier;

    reconstruct(src.activeSkills, &dst->pActiveSkills, tags::segment<CHARACTER_SKILL_FIRST_VISIBLE, CHARACTER_SKILL_LAST_VISIBLE>);
    reconstruct(src.achievedAwardsBits, &dst->_achievedAwardsBits, tags::reverseBits);
    reconstruct(src.haveSpell, &dst->bHaveSpell);

    dst->pure_luck_used = src.pureLuckUsed;
    dst->pure_speed_used = src.pureSpeedUsed;
    dst->pure_intellect_used = src.pureIntellectUsed;
    dst->pure_endurance_used = src.pureEnduranceUsed;
    dst->pure_personality_used = src.purePersonalityUsed;
    dst->pure_accuracy_used = src.pureAccuracyUsed;
    dst->pure_might_used = src.pureMightUsed;

    reconstruct(src.inventoryItems, &dst->pInventoryItemList);
    reconstruct(src.inventoryMatrix, &dst->pInventoryMatrix);

    dst->sResFireBase = src.resFireBase;
    dst->sResAirBase = src.resAirBase;
    dst->sResWaterBase = src.resWaterBase;
    dst->sResEarthBase = src.resEarthBase;
    dst->sResPhysicalBase = src.resPhysicalBase;
    dst->sResMagicBase = src.resMagicBase;
    dst->sResSpiritBase = src.resSpiritBase;
    dst->sResMindBase = src.resMindBase;
    dst->sResBodyBase = src.resBodyBase;
    dst->sResLightBase = src.resLightBase;
    dst->sResDarkBase = src.resDarkBase;
    dst->sResFireBonus = src.resFireBonus;
    dst->sResAirBonus = src.resAirBonus;
    dst->sResWaterBonus = src.resWaterBonus;
    dst->sResEarthBonus = src.resEarthBonus;
    dst->sResPhysicalBonus = src.resPhysicalBonus;
    dst->sResMagicBonus = src.resMagicBonus;
    dst->sResSpiritBonus = src.resSpiritBonus;
    dst->sResMindBonus = src.resMindBonus;
    dst->sResBodyBonus = src.resBodyBonus;
    dst->sResLightBonus = src.resLightBonus;
    dst->sResDarkBonus = src.resDarkBonus;

    reconstruct(src.playerBuffs, &dst->pCharacterBuffs);

    dst->uVoiceID = src.voiceId;
    dst->uPrevVoiceID = src.prevVoiceId;
    dst->uPrevFace = src.prevFace;
    dst->timeToRecovery = Duration::fromTicks(src.timeToRecovery);
    dst->uSkillPoints = src.skillPoints;
    dst->health = src.health;
    dst->mana = src.mana;
    dst->uBirthYear = src.birthYear;

    reconstruct(src.equipment, &dst->pEquipment);

    dst->lastOpenedSpellbookPage = static_cast<MagicSchool>(src.lastOpenedSpellbookPage);
    dst->uQuickSpell = static_cast<SpellId>(src.quickSpell);

    reconstruct(src.playerEventBits, &dst->_characterEventBits, tags::reverseBits);

    dst->_some_attack_bonus = src.someAttackBonus;
    dst->_melee_dmg_bonus = src.meleeDmgBonus;
    dst->_ranged_atk_bonus = src.rangedAttackBonus;
    dst->_ranged_dmg_bonus = src.rangedDmgBonus;
    dst->uFullHealthBonus = src.fullHealthBonus;
    dst->_health_related = src.healthRelated;
    dst->uFullManaBonus = src.fullManaBonus;
    dst->_mana_related = src.manaRelated;
    dst->expression = static_cast<CharacterExpressionID>(src.expression);
    dst->uExpressionTimePassed = Duration::fromTicks(src.expressionTimePassed);
    dst->uExpressionTimeLength = Duration::fromTicks(src.expressionTimeLength);
    dst->uExpressionImageIndex = src.field_1AA2;
    dst->_expression21_animtime = Duration::fromTicks(src._expression21_animtime);
    dst->_expression21_frameset = src._expression21_frameset;

    for (int z = 0; z < dst->vBeacons.size(); z++)
        dst->vBeacons[z].image->Release();
    dst->vBeacons.clear();

    for (unsigned int i = 0; i < 5; ++i) {
        if (src.installedBeacons[i].beaconTime != 0) {
            LloydBeacon beacon;
            beacon.uBeaconTime = Time::fromTicks(src.installedBeacons[i].beaconTime);
            beacon._partyPos.x = src.installedBeacons[i].partyPosX;
            beacon._partyPos.y = src.installedBeacons[i].partyPosY;
            beacon._partyPos.z = src.installedBeacons[i].partyPosZ;
            beacon._partyViewYaw = src.installedBeacons[i].partyViewYaw;
            beacon._partyViewPitch = src.installedBeacons[i].partyViewPitch;
            beacon.mapId = valueOr(mapIdByGamesLodIndex, src.installedBeacons[i].mapIndexInGamesLod, MAP_INVALID);
            dst->vBeacons.push_back(beacon);
        }
    }

    dst->uNumDivineInterventionCastsThisDay = src.numDivineInterventionCasts;
    dst->uNumArmageddonCasts = src.numArmageddonCasts;
    dst->uNumFireSpikeCasts = src.numFireSpikeCasts;
}

void snapshot(const Icon &src, IconFrame_MM7 *dst) {
    memzero(dst);

    snapshot(src.GetAnimationName(), &dst->animationName);
    dst->animLength = src.GetAnimLength().ticks() / 8;

    snapshot(src.pTextureName, &dst->textureName);
    dst->animTime = src.GetAnimTime().ticks() / 8;
    dst->flags = src.uFlags;
}

void reconstruct(const IconFrame_MM7 &src, Icon *dst) {
    std::string name;
    reconstruct(src.animationName, &name);
    dst->SetAnimationName(name);
    dst->SetAnimLength(Duration::fromTicks(8 * src.animLength));

    reconstruct(src.textureName, &dst->pTextureName);
    dst->SetAnimTime(Duration::fromTicks(8 * src.animTime));
    dst->uFlags = src.flags;
}

void snapshot(const UIAnimation &src, UIAnimation_MM7 *dst) {
    memzero(dst);

    /* 000 */ dst->iconId = src.icon->id;
    /* 004 */ dst->animTime = src.uAnimTime;
    /* 006 */ dst->animLength = src.uAnimLength.ticks();
    /* 008 */ dst->x = src.x;
    /* 00A */ dst->y = src.y;
}

void reconstruct(const UIAnimation_MM7 &src, UIAnimation *dst) {
    dst->icon = pIconsFrameTable->GetIcon(src.iconId);
    ///* 000 */ anim->uIconID = src.uIconID;
    /* 004 */ dst->uAnimTime = src.animTime;
    /* 006 */ dst->uAnimLength = Duration::fromTicks(src.animLength);
    /* 008 */ dst->x = src.x;
    /* 00A */ dst->y = src.y;
}

void reconstruct(const MonsterDesc_MM6 &src, MonsterDesc *dst) {
    dst->monsterHeight = src.monsterHeight;
    dst->monsterRadius = src.monsterRadius;
    dst->movementSpeed = src.movementSpeed;
    dst->toHitRadius = src.toHitRadius;
    dst->tintColor = colorTable.White;
    reconstruct(src.soundSampleIds, &dst->soundSampleIds, tags::cast<uint16_t, SoundId>);
    reconstruct(src.monsterName, &dst->monsterName);
    reconstruct(src.spriteNames, &dst->spriteNames);
}

void snapshot(const MonsterDesc &src, MonsterDesc_MM7 *dst) {
    memzero(dst);

    dst->monsterHeight = src.monsterHeight;
    dst->monsterRadius = src.monsterRadius;
    dst->movementSpeed = src.movementSpeed;
    dst->toHitRadius = src.toHitRadius;
    dst->tintColor = src.tintColor.c32();
    snapshot(src.soundSampleIds, &dst->soundSampleIds, tags::cast<SoundId, uint16_t>);
    snapshot(src.monsterName, &dst->monsterName);
    snapshot(src.spriteNames, &dst->spriteNames);
    dst->spriteNamesUnused[0].fill('\0');
    dst->spriteNamesUnused[1].fill('\0');
}

void reconstruct(const MonsterDesc_MM7 &src, MonsterDesc *dst) {
    dst->monsterHeight = src.monsterHeight;
    dst->monsterRadius = src.monsterRadius;
    dst->movementSpeed = src.movementSpeed;
    dst->toHitRadius = src.toHitRadius;
    dst->tintColor = Color::fromC32(src.tintColor);
    reconstruct(src.soundSampleIds, &dst->soundSampleIds, tags::cast<uint16_t, SoundId>);
    reconstruct(src.monsterName, &dst->monsterName);
    reconstruct(src.spriteNames, &dst->spriteNames);
}

void snapshot(const ActorJob &src, ActorJob_MM7 *dst) {
    memzero(dst);

    snapshot(src.vPos, &dst->pos);
    dst->attributes = src.uAttributes;
    dst->action = src.uAction;
    dst->hour = src.uHour;
    dst->day = src.uDay;
    dst->month = src.uMonth;
}

void reconstruct(const ActorJob_MM7 &src, ActorJob *dst) {
    reconstruct(src.pos, &dst->vPos);
    dst->uAttributes = src.attributes;
    dst->uAction = src.action;
    dst->uHour = src.hour;
    dst->uDay = src.day;
    dst->uMonth = src.month;
}

void snapshot(const Actor &src, Actor_MM7 *dst) {
    memzero(dst);

    snapshot(src.name, &dst->pActorName);

    dst->sNPC_ID = src.npcId;
    dst->uAttributes = std::to_underlying(src.attributes);
    dst->sCurrentHP = src.currentHP;

    dst->pMonsterInfo.level = src.monsterInfo.level;
    dst->pMonsterInfo.treasureDropChance = src.monsterInfo.treasureDropChance;
    dst->pMonsterInfo.goldDiceRolls = src.monsterInfo.goldDiceRolls;
    dst->pMonsterInfo.goldDiceSides = src.monsterInfo.goldDiceSides;
    dst->pMonsterInfo.treasureLevel = std::to_underlying(src.monsterInfo.treasureLevel);
    dst->pMonsterInfo.treasureType = std::to_underlying(src.monsterInfo.treasureType);
    dst->pMonsterInfo.flying = src.monsterInfo.flying;
    dst->pMonsterInfo.movementType = std::to_underlying(src.monsterInfo.movementType);
    dst->pMonsterInfo.aiType = std::to_underlying(src.monsterInfo.aiType);
    dst->pMonsterInfo.hostilityType = std::to_underlying(src.monsterInfo.hostilityType);
    dst->pMonsterInfo.specialAttackType = std::to_underlying(src.monsterInfo.specialAttackType);
    dst->pMonsterInfo.specialAttackLevel = src.monsterInfo.specialAttackLevel;
    dst->pMonsterInfo.attack1Type = std::to_underlying(src.monsterInfo.attack1Type);
    dst->pMonsterInfo.attack1DamageDiceRolls = src.monsterInfo.attack1DamageDiceRolls;
    dst->pMonsterInfo.attack1DamageDiceSides = src.monsterInfo.attack1DamageDiceSides;
    dst->pMonsterInfo.attack1DamageBonus = src.monsterInfo.attack1DamageBonus;
    dst->pMonsterInfo.attack1MissileType = src.monsterInfo.attack1MissileType;
    dst->pMonsterInfo.attack2Chance = src.monsterInfo.attack2Chance;
    dst->pMonsterInfo.attack2Type = std::to_underlying(src.monsterInfo.attack2Type);
    dst->pMonsterInfo.attack2DamageDiceRolls = src.monsterInfo.attack2DamageDiceRolls;
    dst->pMonsterInfo.attack2DamageDiceSides = src.monsterInfo.attack2DamageDiceSides;
    dst->pMonsterInfo.attack2DamageBonus = src.monsterInfo.attack2DamageBonus;
    dst->pMonsterInfo.attack2MissileType = src.monsterInfo.attack2MissileType;
    dst->pMonsterInfo.spell1UseChance = src.monsterInfo.spell1UseChance;
    dst->pMonsterInfo.spell1Id = std::to_underlying(src.monsterInfo.spell1Id);
    dst->pMonsterInfo.spell2UseChance = src.monsterInfo.spell2UseChance;
    dst->pMonsterInfo.spell2Id = std::to_underlying(src.monsterInfo.spell2Id);
    dst->pMonsterInfo.resFire = src.monsterInfo.resFire;
    dst->pMonsterInfo.resAir = src.monsterInfo.resAir;
    dst->pMonsterInfo.resWater = src.monsterInfo.resWater;
    dst->pMonsterInfo.resEarth = src.monsterInfo.resEarth;
    dst->pMonsterInfo.resMind = src.monsterInfo.resMind;
    dst->pMonsterInfo.resSpirit = src.monsterInfo.resSpirit;
    dst->pMonsterInfo.resBody = src.monsterInfo.resBody;
    dst->pMonsterInfo.resLight = src.monsterInfo.resLight;
    dst->pMonsterInfo.resDark = src.monsterInfo.resDark;
    dst->pMonsterInfo.resPhysical = src.monsterInfo.resPhysical;
    dst->pMonsterInfo.specialAbilityType = std::to_underlying(src.monsterInfo.specialAbilityType);
    dst->pMonsterInfo.specialAbilityDamageDiceRolls = src.monsterInfo.specialAbilityDamageDiceRolls;
    dst->pMonsterInfo.specialAbilityDamageDiceSides = src.monsterInfo.specialAbilityDamageDiceSides;
    dst->pMonsterInfo.specialAbilityDamageDiceBonus = src.monsterInfo.specialAbilityDamageDiceBonus;
    dst->pMonsterInfo.numCharactersAttackedPerSpecialAbility = src.monsterInfo.numCharactersAttackedPerSpecialAbility;
    dst->pMonsterInfo.id = std::to_underlying(src.monsterInfo.id);
    dst->pMonsterInfo.bloodSplatOnDeath = src.monsterInfo.bloodSplatOnDeath;
    snapshot(src.monsterInfo.spell1SkillMastery, &dst->pMonsterInfo.spell1SkillMastery);
    snapshot(src.monsterInfo.spell2SkillMastery, &dst->pMonsterInfo.spell2SkillMastery);
    dst->pMonsterInfo.field_3C_some_special_attack = src.monsterInfo.field_3C_some_special_attack;
    dst->pMonsterInfo.field_3E = src.monsterInfo.field_3E;
    dst->pMonsterInfo.hp = src.monsterInfo.hp;
    dst->pMonsterInfo.ac = src.monsterInfo.ac;
    dst->pMonsterInfo.exp = src.monsterInfo.exp;
    dst->pMonsterInfo.baseSpeed = src.monsterInfo.baseSpeed;
    dst->pMonsterInfo.recoveryTime = src.monsterInfo.recoveryTime.ticks();
    dst->pMonsterInfo.attackPreferences = std::to_underlying(src.monsterInfo.attackPreferences);
    dst->word_000084_range_attack = src.word_000084_range_attack;
    dst->word_000086_some_monster_id = std::to_underlying(src.word_000086_some_monster_id);  // base monster class monsterlist id
    dst->uActorRadius = src.radius;
    dst->uActorHeight = src.height;
    dst->uMovementSpeed = src.moveSpeed;
    snapshot(src.pos, &dst->vPosition);
    snapshot(src.velocity, &dst->vVelocity);
    dst->uYawAngle = src.yawAngle;
    dst->uPitchAngle = src.pitchAngle;
    dst->uSectorID = src.sectorId;
    dst->uCurrentActionLength = src.currentActionLength.ticks();
    snapshot(src.initialPosition, &dst->vInitialPosition);
    snapshot(src.guardingPosition, &dst->vGuardingPosition);
    dst->uTetherDistance = src.tetherDistance;
    dst->uAIState = std::to_underlying(src.aiState);
    dst->uCurrentActionAnimation = std::to_underlying(src.currentActionAnimation);
    dst->uCarriedItemID = std::to_underlying(src.carriedItemId);
    dst->uCurrentActionTime = src.currentActionTime.ticks();

    snapshot(src.spriteIds, &dst->pSpriteIDs);
    snapshot(src.soundSampleIds, &dst->pSoundSampleIDs, tags::cast<SoundId, uint16_t>);
    snapshot(src.buffs, &dst->pActorBuffs);
    snapshot(src.items, &dst->ActorHasItems);

    dst->uGroup = src.group;
    dst->uAlly = std::to_underlying(src.ally);

    snapshot(src.scheduledJobs, &dst->pScheduledJobs);

    dst->uSummonerID = src.summonerId.packed();
    dst->uLastCharacterIDToHit = src.lastCharacterIdToHit.packed();
    dst->dword_000334_unique_name = src.uniqueNameIndex;
}

void reconstruct(const Actor_MM7 &src, Actor *dst) {
    reconstruct(src.pActorName, &dst->name);
    dst->npcId = src.sNPC_ID;
    dst->attributes = ActorAttributes(src.uAttributes);
    dst->currentHP = src.sCurrentHP;

    dst->monsterInfo.level = src.pMonsterInfo.level;
    dst->monsterInfo.treasureDropChance = src.pMonsterInfo.treasureDropChance;
    dst->monsterInfo.goldDiceRolls = src.pMonsterInfo.goldDiceRolls;
    dst->monsterInfo.goldDiceSides = src.pMonsterInfo.goldDiceSides;
    dst->monsterInfo.treasureLevel = static_cast<ItemTreasureLevel>(src.pMonsterInfo.treasureLevel);
    dst->monsterInfo.treasureType = static_cast<RandomItemType>(src.pMonsterInfo.treasureType);
    dst->monsterInfo.flying = src.pMonsterInfo.flying;
    dst->monsterInfo.movementType = static_cast<MonsterMovementType>(src.pMonsterInfo.movementType);
    dst->monsterInfo.aiType = static_cast<MonsterAiType>(src.pMonsterInfo.aiType);
    dst->monsterInfo.hostilityType = static_cast<MonsterHostility>(src.pMonsterInfo.hostilityType);
    dst->monsterInfo.specialAttackType = static_cast<SpecialAttackType>(src.pMonsterInfo.specialAttackType);
    dst->monsterInfo.specialAttackLevel = src.pMonsterInfo.specialAttackLevel;
    dst->monsterInfo.attack1Type = static_cast<DamageType>(src.pMonsterInfo.attack1Type);
    dst->monsterInfo.attack1DamageDiceRolls = src.pMonsterInfo.attack1DamageDiceRolls;
    dst->monsterInfo.attack1DamageDiceSides = src.pMonsterInfo.attack1DamageDiceSides;
    dst->monsterInfo.attack1DamageBonus = src.pMonsterInfo.attack1DamageBonus;
    dst->monsterInfo.attack1MissileType = src.pMonsterInfo.attack1MissileType;
    dst->monsterInfo.attack2Chance = src.pMonsterInfo.attack2Chance;
    dst->monsterInfo.attack2Type = static_cast<DamageType>(src.pMonsterInfo.attack2Type);
    dst->monsterInfo.attack2DamageDiceRolls = src.pMonsterInfo.attack2DamageDiceRolls;
    dst->monsterInfo.attack2DamageDiceSides = src.pMonsterInfo.attack2DamageDiceSides;
    dst->monsterInfo.attack2DamageBonus = src.pMonsterInfo.attack2DamageBonus;
    dst->monsterInfo.attack2MissileType = src.pMonsterInfo.attack2MissileType;
    dst->monsterInfo.spell1UseChance = src.pMonsterInfo.spell1UseChance;
    dst->monsterInfo.spell1Id = static_cast<SpellId>(src.pMonsterInfo.spell1Id);
    dst->monsterInfo.spell2UseChance = src.pMonsterInfo.spell2UseChance;
    dst->monsterInfo.spell2Id = static_cast<SpellId>(src.pMonsterInfo.spell2Id);
    dst->monsterInfo.resFire = src.pMonsterInfo.resFire;
    dst->monsterInfo.resAir = src.pMonsterInfo.resAir;
    dst->monsterInfo.resWater = src.pMonsterInfo.resWater;
    dst->monsterInfo.resEarth = src.pMonsterInfo.resEarth;
    dst->monsterInfo.resMind = src.pMonsterInfo.resMind;
    dst->monsterInfo.resSpirit = src.pMonsterInfo.resSpirit;
    dst->monsterInfo.resBody = src.pMonsterInfo.resBody;
    dst->monsterInfo.resLight = src.pMonsterInfo.resLight;
    dst->monsterInfo.resDark = src.pMonsterInfo.resDark;
    dst->monsterInfo.resPhysical = src.pMonsterInfo.resPhysical;
    dst->monsterInfo.specialAbilityType = static_cast<MonsterSpecialAbility>(src.pMonsterInfo.specialAbilityType);
    dst->monsterInfo.specialAbilityDamageDiceRolls = src.pMonsterInfo.specialAbilityDamageDiceRolls;
    dst->monsterInfo.specialAbilityDamageDiceSides = src.pMonsterInfo.specialAbilityDamageDiceSides;
    dst->monsterInfo.specialAbilityDamageDiceBonus = src.pMonsterInfo.specialAbilityDamageDiceBonus;
    dst->monsterInfo.numCharactersAttackedPerSpecialAbility = src.pMonsterInfo.numCharactersAttackedPerSpecialAbility;
    dst->monsterInfo.id = static_cast<MonsterId>(src.pMonsterInfo.id);
    dst->monsterInfo.bloodSplatOnDeath = src.pMonsterInfo.bloodSplatOnDeath;
    reconstruct(src.pMonsterInfo.spell1SkillMastery, &dst->monsterInfo.spell1SkillMastery);
    reconstruct(src.pMonsterInfo.spell2SkillMastery, &dst->monsterInfo.spell2SkillMastery);
    dst->monsterInfo.field_3C_some_special_attack = src.pMonsterInfo.field_3C_some_special_attack;
    dst->monsterInfo.field_3E = src.pMonsterInfo.field_3E;
    dst->monsterInfo.hp = src.pMonsterInfo.hp;
    dst->monsterInfo.ac = src.pMonsterInfo.ac;
    dst->monsterInfo.exp = src.pMonsterInfo.exp;
    dst->monsterInfo.baseSpeed = src.pMonsterInfo.baseSpeed;
    dst->monsterInfo.recoveryTime = Duration::fromTicks(src.pMonsterInfo.recoveryTime);
    dst->monsterInfo.attackPreferences = static_cast<MonsterAttackPreferences>(src.pMonsterInfo.attackPreferences);
    dst->word_000084_range_attack = src.word_000084_range_attack;
    dst->word_000086_some_monster_id = static_cast<MonsterId>(src.word_000086_some_monster_id);  // base monster class monsterlist id
    dst->radius = src.uActorRadius;
    dst->height = src.uActorHeight;
    dst->moveSpeed = src.uMovementSpeed;
    reconstruct(src.vPosition, &dst->pos);
    reconstruct(src.vVelocity, &dst->velocity);
    dst->yawAngle = src.uYawAngle;
    dst->pitchAngle = src.uPitchAngle;
    dst->sectorId = src.uSectorID;
    dst->currentActionLength = Duration::fromTicks(src.uCurrentActionLength);
    reconstruct(src.vInitialPosition, &dst->initialPosition);
    reconstruct(src.vGuardingPosition, &dst->guardingPosition);
    dst->tetherDistance = src.uTetherDistance;
    dst->aiState = static_cast<AIState>(src.uAIState);
    dst->currentActionAnimation = static_cast<ActorAnimation>(src.uCurrentActionAnimation);
    dst->carriedItemId = ItemId(src.uCarriedItemID);
    dst->currentActionTime = Duration::fromTicks(src.uCurrentActionTime);

    reconstruct(src.pSpriteIDs, &dst->spriteIds);
    reconstruct(src.pSoundSampleIDs, &dst->soundSampleIds, tags::cast<uint16_t, SoundId>);
    reconstruct(src.pActorBuffs, &dst->buffs);
    reconstruct(src.ActorHasItems, &dst->items);

    dst->group = src.uGroup;
    dst->ally = static_cast<MonsterType>(src.uAlly);

    reconstruct(src.pScheduledJobs, &dst->scheduledJobs);

    dst->summonerId = Pid::fromPacked(src.uSummonerID);
    dst->lastCharacterIdToHit = Pid::fromPacked(src.uLastCharacterIDToHit);
    dst->uniqueNameIndex = src.dword_000334_unique_name;
}

void snapshot(const BLVDoor &src, BLVDoor_MM7 *dst) {
    memzero(dst);

    dst->uAttributes = std::to_underlying(src.uAttributes);
    dst->uDoorID = src.uDoorID;
    dst->uTimeSinceTriggered = src.uTimeSinceTriggered.ticks();
    dst->vDirection = src.vDirection;
    dst->uMoveLength = src.uMoveLength;
    dst->uCloseSpeed = src.uCloseSpeed;
    dst->uOpenSpeed = src.uOpenSpeed;
    dst->uNumVertices = src.uNumVertices;
    dst->uNumFaces = src.uNumFaces;
    dst->uNumSectors = src.uNumSectors;
    dst->uNumOffsets = src.uNumOffsets;
    dst->uState = std::to_underlying(src.uState);
}

void reconstruct(const BLVDoor_MM7 &src, BLVDoor *dst) {
    dst->uAttributes = static_cast<DoorAttributes>(src.uAttributes);
    dst->uDoorID = src.uDoorID;
    dst->uTimeSinceTriggered = Duration::fromTicks(src.uTimeSinceTriggered);
    dst->vDirection = src.vDirection;
    dst->uMoveLength = src.uMoveLength;
    dst->uCloseSpeed = src.uCloseSpeed;
    dst->uOpenSpeed = src.uOpenSpeed;
    dst->uNumVertices = src.uNumVertices;
    dst->uNumFaces = src.uNumFaces;
    dst->uNumSectors = src.uNumSectors;
    dst->uNumOffsets = src.uNumOffsets;
    dst->uState = static_cast<DoorState>(src.uState);
}

void snapshot(const BLVSector &src, BLVSector_MM7 *dst) {
    memzero(dst);

    dst->field_0 = src.field_0;
    dst->uNumFloors = src.uNumFloors;
    dst->uNumWalls = src.uNumWalls;
    dst->uNumCeilings = src.uNumCeilings;
    dst->uNumFluids = src.uNumFluids;
    dst->uNumPortals = src.uNumPortals;
    dst->uNumFaces = src.uNumFaces;
    dst->uNumNonBSPFaces = src.uNumNonBSPFaces;
    dst->uNumCylinderFaces = src.uNumCylinderFaces;
    dst->pCylinderFaces = src.pCylinderFaces;
    dst->uNumCogs = src.uNumCogs;
    dst->uNumDecorations = src.uNumDecorations;
    dst->uNumMarkers = src.uNumMarkers;
    dst->uNumLights = src.uNumLights;
    dst->uWaterLevel = src.uWaterLevel;
    dst->uMistLevel = src.uMistLevel;
    dst->uLightDistanceMultiplier = src.uLightDistanceMultiplier;
    dst->uMinAmbientLightLevel = src.uMinAmbientLightLevel;
    dst->uFirstBSPNode = src.uFirstBSPNode;
    dst->exit_tag = src.exit_tag;
    snapshot(src.pBounding, &dst->pBounding);
}

void reconstruct(const BLVSector_MM7 &src, BLVSector *dst) {
    dst->field_0 = src.field_0;
    dst->uNumFloors = src.uNumFloors;
    dst->uNumWalls = src.uNumWalls;
    dst->uNumCeilings = src.uNumCeilings;
    dst->uNumFluids = src.uNumFluids;
    dst->uNumPortals = src.uNumPortals;
    dst->uNumFaces = src.uNumFaces;
    dst->uNumNonBSPFaces = src.uNumNonBSPFaces;
    dst->uNumCylinderFaces = src.uNumCylinderFaces;
    dst->pCylinderFaces = src.pCylinderFaces;
    dst->uNumCogs = src.uNumCogs;
    dst->uNumDecorations = src.uNumDecorations;
    dst->uNumMarkers = src.uNumMarkers;
    dst->uNumLights = src.uNumLights;
    dst->uWaterLevel = src.uWaterLevel;
    dst->uMistLevel = src.uMistLevel;
    dst->uLightDistanceMultiplier = src.uLightDistanceMultiplier;
    dst->uMinAmbientLightLevel = src.uMinAmbientLightLevel;
    dst->uFirstBSPNode = src.uFirstBSPNode;
    dst->exit_tag = src.exit_tag;
    reconstruct(src.pBounding, &dst->pBounding);
}

void snapshot(const GUICharMetric &src, GUICharMetric_MM7 *dst) {
    memzero(dst);

    dst->uLeftSpacing = src.uLeftSpacing;
    dst->uWidth = src.uWidth;
    dst->uRightSpacing = src.uRightSpacing;
}

void reconstruct(const GUICharMetric_MM7 &src, GUICharMetric *dst) {
    dst->uLeftSpacing = src.uLeftSpacing;
    dst->uWidth = src.uWidth;
    dst->uRightSpacing = src.uRightSpacing;
}

void reconstruct(const FontHeader_MM7 &src, FontHeader *dst) {
    dst->cFirstChar = src.cFirstChar;
    dst->cLastChar = src.cLastChar;
    dst->uFontHeight = src.uFontHeight;

    reconstruct(src.pMetrics, &dst->pMetrics);
    reconstruct(src.font_pixels_offset, &dst->font_pixels_offset);
}

void reconstruct(const ODMFace_MM7 &src, ODMFace *dst) {
    reconstruct(src.facePlane, &dst->facePlane);
    dst->zCalc.init(dst->facePlane);
    dst->uAttributes = FaceAttributes(src.attributes);
    dst->pVertexIDs = src.pVertexIDs;
    dst->pTextureUIDs = src.pTextureUIDs;
    dst->pTextureVIDs = src.pTextureVIDs;
    dst->resource = nullptr;
    dst->sTextureDeltaU = src.sTextureDeltaU;
    dst->sTextureDeltaV = src.sTextureDeltaV;
    reconstruct(src.pBoundingBox, &dst->pBoundingBox);
    dst->sCogNumber = src.sCogNumber;
    dst->sCogTriggeredID = src.sCogTriggeredID;
    dst->sCogTriggerType = src.sCogTriggerType;
    dst->uNumVertices = src.uNumVertices;
    dst->uPolygonType = static_cast<PolygonType>(src.uPolygonType);
    dst->uShadeType = src.uShadeType;
    dst->bVisible = src.bVisible;
}

void reconstruct(const SpawnPoint_MM7 &src, SpawnPoint *dst) {
    dst->vPosition = src.vPosition;
    dst->uRadius = src.uRadius;
    dst->uKind = static_cast<ObjectType>(src.uKind);
    if (dst->uKind == OBJECT_Actor) {
        dst->uItemIndex = ITEM_TREASURE_LEVEL_INVALID;
        dst->uMonsterIndex = src.uIndex;
    } else {
        assert(dst->uKind == OBJECT_Item);
        dst->uItemIndex = static_cast<ItemTreasureLevel>(src.uIndex);
        dst->uMonsterIndex = 0;
    }
    dst->uAttributes = src.uAttributes;
    dst->uGroup = src.uGroup;
}

void snapshot(const SpriteObject &src, SpriteObject_MM7 *dst) {
    memzero(dst);

    dst->uType = std::to_underlying(src.uType);
    dst->uObjectDescID = src.uObjectDescID;
    dst->vPosition = src.vPosition.toInt();
    snapshot(src.vVelocity, &dst->vVelocity);
    dst->uFacing = src.uFacing;
    dst->uSoundID = src.uSoundID;
    dst->uAttributes = std::to_underlying(src.uAttributes);
    dst->uSectorID = src.uSectorID;
    dst->uTimeSinceCreated = src.timeSinceCreated.ticks();
    dst->tempLifetime = src.tempLifetime.ticks();
    dst->field_22_glow_radius_multiplier = src.field_22_glow_radius_multiplier;
    snapshot(src.containing_item, &dst->containing_item);
    dst->uSpellID = std::to_underlying(src.uSpellID);
    dst->spell_level = src.spell_level;
    dst->spell_skill = std::to_underlying(src.spell_skill);
    dst->field_54 = src.field_54;
    dst->spell_caster_pid = src.spell_caster_pid.packed();
    dst->spell_target_pid = src.spell_target_pid.packed();
    dst->field_60_distance_related_prolly_lod = src.field_60_distance_related_prolly_lod;
    dst->spellCasterAbility = std::to_underlying(src.spellCasterAbility);
    dst->initialPosition = src.initialPosition.toInt();
}

void reconstruct(const SpriteObject_MM7 &src, SpriteObject *dst) {
    dst->uType = static_cast<SpriteId>(src.uType);
    dst->uObjectDescID = src.uObjectDescID;
    dst->vPosition = src.vPosition.toFloat();
    reconstruct(src.vVelocity, &dst->vVelocity);
    dst->uFacing = src.uFacing;
    dst->uSoundID = src.uSoundID;
    dst->uAttributes = SpriteAttributes(src.uAttributes);
    dst->uSectorID = src.uSectorID;
    dst->timeSinceCreated = Duration::fromTicks(src.uTimeSinceCreated);
    dst->tempLifetime = Duration::fromTicks(src.tempLifetime);
    dst->field_22_glow_radius_multiplier = src.field_22_glow_radius_multiplier;
    reconstruct(src.containing_item, &dst->containing_item);
    dst->uSpellID = static_cast<SpellId>(src.uSpellID);
    dst->spell_level = src.spell_level;
    dst->spell_skill = static_cast<CharacterSkillMastery>(src.spell_skill);
    dst->field_54 = src.field_54;
    dst->spell_caster_pid = Pid::fromPacked(src.spell_caster_pid);
    dst->spell_target_pid = Pid::fromPacked(src.spell_target_pid);
    dst->field_60_distance_related_prolly_lod = src.field_60_distance_related_prolly_lod;
    dst->spellCasterAbility = static_cast<ActorAbility>(src.spellCasterAbility);
    dst->initialPosition = src.initialPosition.toFloat();
}

void reconstruct(const ChestDesc_MM7 &src, ChestDesc *dst) {
    reconstruct(src.pName, &dst->sName);
    dst->uWidth = src.uWidth;
    dst->uHeight = src.uHeight;
    dst->uTextureID = src.uTextureID;
}

void reconstruct(const DecorationDesc_MM6 &src, DecorationDesc *dst) {
    reconstruct(src.name, &dst->name);
    reconstruct(src.field_20, &dst->field_20);
    dst->uType = src.uType;
    dst->uDecorationHeight = src.uDecorationHeight;
    dst->uRadius = src.uRadius;
    dst->uLightRadius = src.uLightRadius;
    dst->uSpriteID = src.uSpriteID;
    dst->uFlags = DecorationDescFlags(src.uFlags);
    dst->uSoundID = static_cast<SoundId>(src.uSoundID);

    dst->uColoredLight.r = 255;
    dst->uColoredLight.g = 255;
    dst->uColoredLight.b = 255;
    dst->uColoredLight.a = 255;
}

void reconstruct(const DecorationDesc_MM7 &src, DecorationDesc *dst) {
    reconstruct(static_cast<const DecorationDesc_MM6 &>(src), dst);

    dst->uColoredLight.r = src.uColoredLightRed;
    dst->uColoredLight.g = src.uColoredLightGreen;
    dst->uColoredLight.b = src.uColoredLightBlue;
    dst->uColoredLight.a = 255;
}

void snapshot(const Chest &src, Chest_MM7 *dst) {
    memzero(dst);

    dst->uChestBitmapID = src.uChestBitmapID;
    dst->uFlags = std::to_underlying(src.uFlags);
    snapshot(src.igChestItems, &dst->igChestItems);
    snapshot(src.pInventoryIndices, &dst->pInventoryIndices);
}

void reconstruct(const Chest_MM7 &src, Chest *dst) {
    dst->uChestBitmapID = src.uChestBitmapID;
    dst->uFlags = ChestFlags(src.uFlags);
    reconstruct(src.igChestItems, &dst->igChestItems);
    reconstruct(src.pInventoryIndices, &dst->pInventoryIndices);

    // fix placedInChest field for old saves
    int chestArea = dst->pInventoryIndices.size();
    for (int item = 0; item < chestArea; item++) {
        if (dst->igChestItems[item].uItemID == ITEM_NULL) {
            continue;
        }
        for (int position = 0; position < chestArea; position++) {
            if (dst->pInventoryIndices[position] == item + 1) {
                dst->igChestItems[item].placedInChest = true;
                break;
            }
        }
    }
}

void reconstruct(const BLVLight_MM7 &src, BLVLight *dst) {
    reconstruct(src.vPosition, &dst->vPosition);
    dst->uRadius = src.uRadius;
    dst->uRed = src.uRed;
    dst->uGreen = src.uGreen;
    dst->uBlue = src.uBlue;
    dst->uType = src.uType;
    dst->uAtributes = src.uAtributes;
    dst->uBrightness = src.uBrightness;
}

void reconstruct(const OverlayDesc_MM7 &src, OverlayDesc *dst) {
    dst->uOverlayID = src.uOverlayID;
    dst->uOverlayType = src.uOverlayType;
    dst->uSpriteFramesetID = src.uSpriteFramesetID;
    dst->spriteFramesetGroup = src.spriteFramesetGroup;
}

void reconstruct(const PlayerFrame_MM7 &src, PlayerFrame *dst) {
    dst->expression = static_cast<CharacterExpressionID>(src.expression);
    dst->uTextureID = src.uTextureID;
    dst->uAnimTime = Duration::fromTicks(src.uAnimTime * 8);
    dst->uAnimLength = Duration::fromTicks(src.uAnimLength * 8);
    dst->uFlags = src.uFlags;
}

void reconstruct(const LevelDecoration_MM7 &src, LevelDecoration *dst) {
    dst->uDecorationDescID = src.uDecorationDescID;
    dst->uFlags = LevelDecorationFlags(src.uFlags);
    dst->vPosition = src.vPosition.toFloat();
    dst->_yawAngle = (TrigLUT.uIntegerHalfPi * src.field_1A) / 90;
    // src.field_1A - actually yaw angle in degrees, used when _yawAngle is not set.
    if (src._yawAngle)
        dst->_yawAngle = src._yawAngle;
    dst->uCog = src.uCog;
    dst->uEventID = src.uEventID;
    dst->uTriggerRange = src.uTriggerRange;
    dst->eventVarId = src.eventVarId - 75; // Was changed because all current usages are without this 75 shift
}

void reconstruct(const BLVFaceExtra_MM7 &src, BLVFaceExtra *dst) {
    dst->face_id = src.face_id;
    dst->uAdditionalBitmapID = src.uAdditionalBitmapID;
    dst->sTextureDeltaU = src.sTextureDeltaU;
    dst->sTextureDeltaV = src.sTextureDeltaV;
    dst->sCogNumber = src.sCogNumber;
    dst->uEventID = src.uEventID;
}

void reconstruct(const BSPNode_MM7 &src, BSPNode *dst) {
    dst->uFront = src.uFront;
    dst->uBack = src.uBack;
    dst->uBSPFaceIDOffset = src.uBSPFaceIDOffset;
    dst->uNumBSPFaces = src.uNumBSPFaces;
}

void reconstruct(const BLVMapOutline_MM7 &src, BLVMapOutline *dst) {
    dst->uVertex1ID = src.uVertex1ID;
    dst->uVertex2ID = src.uVertex2ID;
    dst->uFace1ID = src.uFace1ID;
    dst->uFace2ID = src.uFace2ID;
    dst->sZ = src.sZ;
    dst->uFlags = src.uFlags;
}

void reconstruct(const ObjectDesc_MM6 &src, ObjectDesc *dst) {
    reconstruct(src.name, &dst->name);
    dst->uObjectID = static_cast<SpriteId>(src.uObjectID);
    dst->uRadius = src.uRadius;
    dst->uHeight = src.uHeight;
    dst->uFlags = ObjectDescFlags(src.uFlags);
    dst->uSpriteID = src.uSpriteID;
    dst->uLifetime = Duration::fromTicks(src.uLifetime);
    // Note: src.uParticleTrailColor16 is ignored.
    dst->uParticleTrailColor = Color(src.uParticleTrailColorR, src.uParticleTrailColorG, src.uParticleTrailColorB);
    dst->uSpeed = src.uSpeed;
}

void reconstruct(const ObjectDesc_MM7 &src, ObjectDesc *dst) {
    reconstruct(src.name, &dst->name);
    dst->uObjectID = static_cast<SpriteId>(src.uObjectID);
    dst->uRadius = src.uRadius;
    dst->uHeight = src.uHeight;
    dst->uFlags = ObjectDescFlags(src.uFlags);
    dst->uSpriteID = src.uSpriteID;
    dst->uLifetime = Duration::fromTicks(src.uLifetime);
    // Note: src.uParticleTrailColor32 is ignored.
    dst->uParticleTrailColor = Color(src.uParticleTrailColorR, src.uParticleTrailColorG, src.uParticleTrailColorB);
    dst->uSpeed = src.uSpeed;
}

void snapshot(const LocationTime &src, LocationTime_MM7 *dst) {
    memzero(dst);

    snapshot(src.last_visit, &dst->last_visit);
    snapshot(src.sky_texture_name, &dst->sky_texture_name);
    dst->day_attrib = std::to_underlying(src.day_attrib);
    dst->day_fogrange_1 = src.day_fogrange_1;
    dst->day_fogrange_2 = src.day_fogrange_2;
}

void reconstruct(const LocationTime_MM7 &src, LocationTime *dst) {
    reconstruct(src.last_visit, &dst->last_visit);
    reconstruct(src.sky_texture_name, &dst->sky_texture_name);
    dst->day_attrib = static_cast<MapWeatherFlags>(src.day_attrib);
    dst->day_fogrange_1 = src.day_fogrange_1;
    dst->day_fogrange_2 = src.day_fogrange_2;
}

void reconstruct(const SoundInfo_MM6 &src, SoundInfo *dst) {
    reconstruct(src.pSoundName, &dst->sName);
    dst->uSoundID = static_cast<SoundId>(src.uSoundID);
    dst->eType = static_cast<SoundType>(src.eType);
    dst->uFlags = static_cast<SoundFlags>(src.uFlags);
}

void reconstruct(const SoundInfo_MM7 &src, SoundInfo *dst) {
    reconstruct(static_cast<const SoundInfo_MM6 &>(src), dst);
}

void snapshot(const LocationInfo &src, LocationInfo_MM7 *dst) {
    memzero(dst);

    dst->respawnCount = src.respawnCount;
    dst->lastRespawnDay = src.lastRespawnDay;
    dst->reputation = src.reputation;
    dst->alertStatus = src.alertStatus;
}

void reconstruct(const LocationInfo_MM7 &src, LocationInfo *dst) {
    dst->respawnCount = src.respawnCount;
    dst->lastRespawnDay = src.lastRespawnDay;
    dst->reputation = src.reputation;
    dst->alertStatus = src.alertStatus;
}

void snapshot(const PersistentVariables &src, PersistentVariables_MM7 *dst) {
    memzero(dst);

    dst->mapVars = src.mapVars;
    dst->decorVars = src.decorVars;
}

void reconstruct(const PersistentVariables_MM7 &src, PersistentVariables *dst) {
    dst->mapVars = src.mapVars;
    dst->decorVars = src.decorVars;
}

void reconstruct(const OutdoorLocationTileType_MM7 &src, OutdoorLocationTileType *dst) {
    dst->tileset = static_cast<Tileset>(src.tileset);
    dst->uTileID = src.tileId;
}

void snapshot(const SaveGameHeader &src, SaveGameHeader_MM7 *dst) {
    memzero(dst);

    snapshot(src.name, &dst->name);
    snapshot(src.locationName, &dst->locationName);
    snapshot(src.playingTime, &dst->playingTime);
}

void reconstruct(const SaveGameHeader_MM7 &src, SaveGameHeader *dst) {
    reconstruct(src.name, &dst->name);
    reconstruct(src.locationName, &dst->locationName);
    reconstruct(src.playingTime, &dst->playingTime);
    // field_30 is ignored.
}
