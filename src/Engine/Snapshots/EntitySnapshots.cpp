#include "EntitySnapshots.h"

#include <algorithm>
#include <string>
#include <unordered_map>

#include "Engine/ArenaEnumFunctions.h"
#include "Engine/Engine.h"
#include "Engine/Graphics/Indoor.h"
#include "Engine/Objects/Decoration.h"
#include "Engine/Objects/DecorationList.h"
#include "Engine/Graphics/Outdoor.h"
#include "Engine/Graphics/Overlays.h"
#include "Engine/Graphics/Sprites.h"
#include "Engine/Tables/TextureFrameTable.h"
#include "Engine/Graphics/Image.h"
#include "Engine/Objects/Actor.h"
#include "Engine/Objects/NPC.h"
#include "Engine/Objects/ObjectList.h"
#include "Engine/Objects/SpriteObject.h"
#include "Engine/Objects/Chest.h"
#include "Engine/Party.h"
#include "Engine/SaveLoad.h"
#include "Engine/Data/IconFrameData.h"
#include "Engine/Data/PortraitFrameData.h"
#include "Engine/Data/TileData.h"
#include "Engine/Data/TileEnumFunctions.h"
#include "Engine/Tables/ChestTable.h"
#include "Engine/Time/Time.h"

#include "Media/Audio/SoundInfo.h"

#include "Library/Color/ColorTable.h"
#include "Library/Logger/Logger.h"
#include "Library/Snapshots/CommonSnapshots.h"

#include "Utility/Memory/MemSet.h"
#include "Utility/String/Ascii.h"
#include "Utility/MapAccess.h"

/**
 * Mapping used for beacon map id serialization.
 *
 * DON'T EDIT, THIS IS AUTOGENERATED CODE.
 *
 * @see runBeaconsCodeGen
 */
static const std::unordered_map<MapId, uint16_t> gamesLodIndexByMapId = {
    {MAP_ERATHIAN_SEWERS, 0},
    {MAP_MAZE, 1},
    {MAP_CASTLE_GLOAMING, 2},
    {MAP_TEMPLE_OF_BAA, 3},
    {MAP_ARENA, 4},
    {MAP_TEMPLE_OF_THE_MOON, 5},
    {MAP_THUNDERFIST_MOUNTAIN, 6},
    {MAP_TULAREAN_CAVES, 7},
    {MAP_TITANS_STRONGHOLD, 8},
    {MAP_BREEDING_ZONE, 9},
    {MAP_WALLS_OF_MIST, 10},
    {MAP_CLANKERS_LABORATORY, 11},
    {MAP_ZOKARRS_TOMB, 12},
    {MAP_SCHOOL_OF_SORCERY, 13},
    {MAP_WATCHTOWER_6, 14},
    {MAP_WINE_CELLAR, 15},
    {MAP_TIDEWATER_CAVERNS, 16},
    {MAP_LORD_MARKHAMS_MANOR, 17},
    {MAP_GRAND_TEMPLE_OF_THE_MOON, 18},
    {MAP_MERCENARY_GUILD, 19},
    {MAP_WHITE_CLIFF_CAVE, 20},
    {MAP_HALL_UNDER_THE_HILL, 21},
    {MAP_LINCOLN, 22},
    {MAP_STONE_CITY, 23},
    {MAP_CELESTE, 24},
    {MAP_PIT, 25},
    {MAP_COLONY_ZOD, 26},
    {MAP_DRAGONS_LAIR, 27},
    {MAP_CASTLE_HARMONDALE, 28},
    {MAP_CASTLE_LAMBENT, 29},
    {MAP_FORT_RIVERSTRIDE, 30},
    {MAP_CASTLE_NAVAN, 31},
    {MAP_CASTLE_GRYPHONHEART, 32},
    {MAP_RED_DWARF_MINES, 33},
    {MAP_NIGHON_TUNNELS, 34},
    {MAP_TUNNELS_TO_EEOFOL, 35},
    {MAP_HAUNTED_MANSION, 36},
    {MAP_BARROW_VII, 37},
    {MAP_BARROW_IV, 38},
    {MAP_BARROW_II, 39},
    {MAP_BARROW_XIV, 40},
    {MAP_BARROW_III, 41},
    {MAP_BARROW_X, 42},
    {MAP_BARROW_XII, 43},
    {MAP_BARROW_V, 44},
    {MAP_BARROW_XI, 45},
    {MAP_BARROW_XV, 46},
    {MAP_BARROW_IX, 47},
    {MAP_BARROW_VI, 48},
    {MAP_BARROW_I, 49},
    {MAP_BARROW_VIII, 50},
    {MAP_BARROW_XIII, 51},
    {MAP_WROMTHRAXS_CAVE, 52},
    {MAP_WILLIAM_SETAGS_TOWER, 53},
    {MAP_HIDDEN_TOMB, 54},
    {MAP_DRAGON_CAVES, 55},
    {MAP_BANDIT_CAVES, 56},
    {MAP_SMALL_HOUSE, 57},
    {MAP_STRANGE_TEMPLE, 58},
    {MAP_EMERALD_ISLAND, 59},
    {MAP_HARMONDALE, 60},
    {MAP_ERATHIA, 61},
    {MAP_TULAREAN_FOREST, 62},
    {MAP_DEYJA, 63},
    {MAP_BRACADA_DESERT, 64},
    {MAP_EVENMORN_ISLAND, 65},
    {MAP_MOUNT_NIGHON, 66},
    {MAP_BARROW_DOWNS, 67},
    {MAP_LAND_OF_THE_GIANTS, 68},
    {MAP_TATALIA, 69},
    {MAP_AVLEE, 70},
    {MAP_SHOALS, 71},
    {MAP_TEMPLE_OF_THE_LIGHT, 72},
    {MAP_TEMPLE_OF_THE_DARK, 73},
    {MAP_GRAND_TEMPLE_OF_THE_SUN, 74},
    {MAP_HALL_OF_THE_PIT, 75},
};
static const std::unordered_map<uint16_t, MapId> mapIdByGamesLodIndex = inverted(gamesLodIndexByMapId);

static void snapshot(const Time &src, int64_t *dst) {
    *dst = src.ticks();
}

static void reconstruct(int64_t src, Time *dst) {
    *dst = Time::fromTicks(src);
}

static void snapshot(const Duration &src, int32_t *dst) {
    *dst = src.ticks();
}

static void reconstruct(int32_t src, Duration *dst) {
    *dst = Duration::fromTicks(src);
}

static void snapshot(const CombinedSkillValue &src, uint16_t *dst) {
    *dst = src.joined();
}

static void reconstruct(const uint16_t &src, CombinedSkillValue *dst) {
    *dst = CombinedSkillValue::fromJoined(src);
}

static void snapshot(const MonsterId &src, int16_t *dst) {
    *dst = std::to_underlying(src);
}

static void reconstruct(int16_t src, MonsterId *dst) {
    *dst = static_cast<MonsterId>(src);
}

void snapshot(const Pid &src, uint16_t *dst) {
    *dst = src.packed();
}

void reconstruct(uint16_t src, Pid *dst) {
    *dst = Pid::fromPacked(src);
}

void snapshot(const Vec3i &src, Vec3s *dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void reconstruct(const Vec3s &src, Vec3i *dst) {
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void snapshot(const Vec3f &src, Vec3s *dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void reconstruct(const Vec3s &src, Vec3f *dst) {
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void snapshot(const Vec3f &src, Vec3i *dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void reconstruct(const Vec3i &src, Vec3f *dst) {
    dst->x = src.x;
    dst->y = src.y;
    dst->z = src.z;
}

void snapshot(const BBoxi &src, BBoxs_MM7 *dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x1 = src.x1;
    dst->x2 = src.x2;
    dst->y1 = src.y1;
    dst->y2 = src.y2;
    dst->z1 = src.z1;
    dst->z2 = src.z2;
}

void reconstruct(const BBoxs_MM7 &src, BBoxi *dst) {
    dst->x1 = src.x1;
    dst->x2 = src.x2;
    dst->y1 = src.y1;
    dst->y2 = src.y2;
    dst->z1 = src.z1;
    dst->z2 = src.z2;
}

void snapshot(const BBoxf& src, BBoxs_MM7* dst) {
    // TODO(captainurist): do we need to check for overflows here?
    dst->x1 = src.x1;
    dst->x2 = src.x2;
    dst->y1 = src.y1;
    dst->y2 = src.y2;
    dst->z1 = src.z1;
    dst->z2 = src.z2;
}

void reconstruct(const BBoxs_MM7& src, BBoxf* dst) {
    dst->x1 = src.x1;
    dst->x2 = src.x2;
    dst->y1 = src.y1;
    dst->y2 = src.y2;
    dst->z1 = src.z1;
    dst->z2 = src.z2;
}

void reconstruct(const Planef_MM7 &src, Planef *dst) {
    dst->normal = src.normal;
    dst->dist = src.dist;
}

void reconstruct(const Planei_MM7 &src, Planef *dst) {
    dst->normal.x = src.normal.x / 65536.0f;
    dst->normal.y = src.normal.y / 65536.0f;
    dst->normal.z = src.normal.z / 65536.0f;
    dst->dist = src.dist / 65536.0f;
}

void reconstruct(const SpriteFrame_MM7 &src, SpriteFrame *dst) {
    reconstruct(src.spriteName, &dst->spriteName);
    dst->spriteName = ascii::toLower(dst->spriteName);

    reconstruct(src.textureName, &dst->textureName);
    dst->textureName = ascii::toLower(dst->textureName);

    dst->sprites.fill(nullptr);

    dst->scale = src.scale / 65536.0f;
    dst->flags = static_cast<SpriteFrameFlags>(src.flags);

    dst->glowRadius = src.glowRadius;
    dst->paletteId = src.paletteId;
    dst->frameLength = Duration::fromTicks(src.frameLength * 8);
    dst->animationLength = Duration::fromTicks(src.animationLength * 8);
}

void reconstruct(const BLVFace_MM7 &src, BLVFace *dst) {
    reconstruct(src.facePlane, &dst->facePlane);
    dst->zCalc.init(dst->facePlane);
    dst->uAttributes = static_cast<FaceAttributes>(src.attributes);
    dst->pVertexIDs = nullptr;
    dst->pVertexUs = nullptr;
    dst->pVertexVs = nullptr;
    dst->uFaceExtraID = src.faceExtraId;
    dst->texture = nullptr;
    dst->animationId = 0;
    dst->uSectorID = src.sectorId;
    dst->uBackSectorID = src.backSectorId;
    reconstruct(src.bounding, &dst->pBounding);
    dst->uPolygonType = static_cast<PolygonType>(src.polygonType);
    dst->uNumVertices = src.numVertices;
}

void reconstruct(const TileData_MM7 &src, TileData *dst) {
    reconstruct(src.textureName, &dst->textureName);
    dst->textureName = ascii::toLower(dst->textureName);

    if (ascii::noCaseStartsWith(dst->textureName, "wtrdr"))
        dst->textureName.insert(0, "h"); // animated water only works with hwtrdr* tiles.

    // We just ignore src.tileId & src.bitmapId.

    reconstruct(src.tileset, &dst->tileset);
    reconstruct(src.variant, &dst->variant, tags::context(isRoad(dst->tileset)), tags::context(dst->textureName));
    dst->flags = static_cast<TileFlags>(src.flags);
}

void reconstruct(const TextureFrameData_MM7 &src, TextureFrameData *dst) {
    reconstruct(src.textureName, &dst->textureName);

    dst->animationLength = Duration::fromTicks(src.animationLength * 8);
    dst->frameLength = Duration::fromTicks(src.frameLength * 8);

    // MM7 uses different enum values for texture frames and portrait frames. We have unified them, so need to properly
    // convert the values here.
    dst->flags = 0;
    if (src.flags & 1)
        dst->flags |= FRAME_HAS_MORE;
    if (src.flags & 2)
        dst->flags |= FRAME_FIRST;
}

void snapshot(const Timer &src, Timer_MM7 *dst) {
    memzero(dst);

    dst->ready = true;
    dst->paused = src._paused;
    dst->turnBased = src._turnBased;
    dst->lastFrameTime = src._lastFrameTime.ticks();
    dst->pauseTime = 0;
    dst->turnBasedTime = 0;
    dst->timeElapsed = src._dt.ticks();
    dst->dtFixpoint = src._dt.realtimeMillisecondsFloat() * 65536.0f;
    dst->totalGameTimeElapsed = src._time.ticks();
}

void reconstruct(const Timer_MM7 &src, Timer *dst) {
    dst->_paused = src.paused;
    dst->_turnBased = src.turnBased;
    dst->_lastFrameTime = Duration::fromTicks(src.lastFrameTime);
    dst->_dt = Duration::fromTicks(src.timeElapsed);
    dst->_time = Duration::fromTicks(src.totalGameTimeElapsed);
}

void snapshot(const NPCData &src, NPCData_MM7 *dst) {
    memzero(dst);

    dst->name.value = !src.name.empty(); // TODO(captainurist): Can drop? Need to check that vanilla doesn't choke here.
    dst->portraitId = src.portraitId;
    dst->flags = std::to_underlying(src.flags);
    dst->fame = src.fame;
    dst->rep = src.rep;
    dst->house = std::to_underlying(src.house);
    dst->profession = std::to_underlying(src.profession);
    dst->greetingIndex = src.greetingIndex;
    dst->canJoin = src.canJoin;
    dst->field_24 = src.field_24;
    dst->evt_A = src.dialogue_1_evt_id;
    dst->evt_B = src.dialogue_2_evt_id;
    dst->evt_C = src.dialogue_3_evt_id;
    dst->evt_D = src.dialogue_4_evt_id;
    dst->evt_E = src.dialogue_5_evt_id;
    dst->evt_F = src.dialogue_6_evt_id;
    dst->sex = std::to_underlying(src.sex);
    dst->hasUsedAbility = src.hasUsedAbility;
    dst->newsTopic = src.newsTopic;
}

void reconstruct(const NPCData_MM7 &src, NPCData *dst) {
    dst->name = src.name.value ? "Dummy" : ""; // TODO(captainurist): can drop?
    dst->portraitId = src.portraitId;
    dst->flags = NpcFlags(src.flags);
    dst->fame = src.fame;
    dst->rep = src.rep;
    dst->house = static_cast<HouseId>(src.house);
    dst->profession = static_cast<NpcProfession>(src.profession);
    dst->greetingIndex = src.greetingIndex;
    dst->canJoin = src.canJoin;
    dst->field_24 = src.field_24;
    dst->dialogue_1_evt_id = src.evt_A;
    dst->dialogue_2_evt_id = src.evt_B;
    dst->dialogue_3_evt_id = src.evt_C;
    dst->dialogue_4_evt_id = src.evt_D;
    dst->dialogue_5_evt_id = src.evt_E;
    dst->dialogue_6_evt_id = src.evt_F;
    dst->sex = static_cast<Sex>(src.sex);
    dst->hasUsedAbility = src.hasUsedAbility;
    dst->newsTopic = src.newsTopic;
}

void snapshot(const ActiveOverlay &src, ActiveOverlay_MM7 *dst) {
    memzero(dst);

    dst->indexToOverlayList = src.indexToOverlayList;
    dst->spriteFrameTime = src.spriteFrameTime;
    dst->animLength = src.animLength;
    dst->screenSpaceX = src.screenSpaceX;
    dst->screenSpaceY = src.screenSpaceY;
    dst->pid = src.pid.packed();
    dst->projSize = src.projSize;
    dst->fpDamageMod = src.fpDamageMod;
}

void reconstruct(const ActiveOverlay_MM7 &src, ActiveOverlay *dst) {
    memzero(dst);

    dst->indexToOverlayList = src.indexToOverlayList;
    dst->spriteFrameTime = src.spriteFrameTime;
    dst->animLength = src.animLength;
    dst->screenSpaceX = src.screenSpaceX;
    dst->screenSpaceY = src.screenSpaceY;
    dst->pid = Pid::fromPacked(src.pid);
    dst->projSize = src.projSize;
    dst->fpDamageMod = src.fpDamageMod;
}

void snapshot(const ActiveOverlayList &src, ActiveOverlayList_MM7 *dst) {
    memzero(dst);

    dst->redraw = true;
    snapshot(src.pOverlays, &dst->overlays);
}

void reconstruct(const ActiveOverlayList_MM7 &src, ActiveOverlayList *dst) {
    reconstruct(src.overlays, &dst->pOverlays);
}

void snapshot(const SpellBuff &src, SpellBuff_MM7 *dst) {
    memzero(dst);

    snapshot(src.expireTime, &dst->expireTime);
    dst->power = src.power;
    dst->skillMastery = std::to_underlying(src.skillMastery);
    dst->overlayId = src.overlayId;
    dst->caster = src.caster;
    dst->isGM = src.isGM;
}

void reconstruct(const SpellBuff_MM7 &src, SpellBuff *dst) {
    reconstruct(src.expireTime, &dst->expireTime);
    dst->power = src.power;
    dst->skillMastery = static_cast<Mastery>(src.skillMastery);
    dst->overlayId = src.overlayId;
    dst->caster = src.caster;
    dst->isGM = src.isGM;
}

void snapshot(const Item &src, Item_MM7 *dst, ContextTag<ItemSlot> slot) {
    memzero(dst);

    dst->itemId = std::to_underlying(src.itemId);
    if (isPotion(src.itemId)) {
        dst->standardEnchantmentOrPotionPower = src.potionPower;
    } else if (src.standardEnchantment) {
        dst->standardEnchantmentOrPotionPower = std::to_underlying(*src.standardEnchantment) + 1;
    } else {
        dst->standardEnchantmentOrPotionPower = 0;
    }
    dst->standardEnchantmentStrength = src.standardEnchantmentStrength;
    if (isGold(src.itemId)) {
        dst->specialEnchantmentOrGoldAmount = src.goldAmount;
    } else {
        dst->specialEnchantmentOrGoldAmount = std::to_underlying(src.specialEnchantment);
    }
    dst->numCharges = src.numCharges;
    dst->flags = std::to_underlying(src.flags);
    dst->equippedSlot = std::to_underlying(*slot);
    dst->maxCharges = src.maxCharges;
    dst->lichJarCharacterIndex = src.lichJarCharacterIndex + 1;
    snapshot(src.enchantmentExpirationTime, &dst->enchantmentExpirationTime);
}

void reconstruct(const Item_MM7 &src, Item *dst) {
    dst->itemId = static_cast<ItemId>(src.itemId);
    if (isPotion(dst->itemId)) {
        dst->potionPower = src.standardEnchantmentOrPotionPower;
        dst->standardEnchantment = {};
    } else if (src.standardEnchantmentOrPotionPower) {
        dst->potionPower = 0;
        dst->standardEnchantment = static_cast<Attribute>(src.standardEnchantmentOrPotionPower - 1);

        // TODO(captainurist): Do this properly for every single enum in this file.
        if (!allEnchantableAttributes().contains(*dst->standardEnchantment))
            dst->standardEnchantment = {};
    } else {
        dst->potionPower = 0;
        dst->standardEnchantment = {};
    }
    dst->standardEnchantmentStrength = src.standardEnchantmentStrength;
    if (isGold(dst->itemId)) {
        dst->goldAmount = src.specialEnchantmentOrGoldAmount;
        dst->specialEnchantment = ITEM_ENCHANTMENT_NULL;
    } else {
        dst->goldAmount = 0;
        dst->specialEnchantment = static_cast<ItemEnchantment>(src.specialEnchantmentOrGoldAmount);
    }
    dst->numCharges = src.numCharges;
    dst->flags = ItemFlags(src.flags);
    // src.equippedSlot is ignored - we handle it externally.
    dst->maxCharges = src.maxCharges;
    dst->lichJarCharacterIndex = src.lichJarCharacterIndex - 1;
    reconstruct(src.enchantmentExpirationTime, &dst->enchantmentExpirationTime);
}

void snapshot(const Party &src, Party_MM7 *dst) {
    memzero(dst);

    dst->field_0 = 25; // Vanilla set this to 25, so we're doing the same just in case.
    dst->partyHeight = src.height;
    dst->defaultPartyHeight = src.height;
    dst->eyeLevel = src.eyeLevel;
    dst->defaultEyeLevel = src.eyeLevel;
    dst->radius = src.radius;
    dst->yawGranularity = src._yawGranularity;
    dst->walkSpeed = src.walkSpeed;
    dst->yawRotationSpeed = src._yawRotationSpeed;
    dst->jumpStrength = src.jump_strength;
    snapshot(src.playing_time, &dst->timePlayed);
    snapshot(src.last_regenerated, &dst->lastRegenerationTime);

    snapshot(src.PartyTimes.bountyHuntNextGenTime, &dst->partyTimes.bountyHuntingNextGenerationTime);
    dst->partyTimes.bountyHuntingNextGenerationTimeUnused.fill(0);

    // Initially was one array but was splitted in two to simplify access with first element as zero
    // because it is corresponding to invalid house ID
    dst->partyTimes.shopsNextGenerationTime0 = 0;
    snapshot(src.PartyTimes.shopNextRefreshTime, &dst->partyTimes.shopsNextGenerationTime);
    snapshot(src.PartyTimes.guildNextRefreshTime, &dst->partyTimes.guildsNextGenerationTime);

    dst->partyTimes.shopBanTime0 = 0;
    snapshot(src.PartyTimes.shopBanTimes, &dst->partyTimes.shopBanTimes);
    snapshot(src.PartyTimes.CounterEventValues, &dst->partyTimes.counterEventValues);
    snapshot(src.PartyTimes.HistoryEventTimes, &dst->partyTimes.historyEventTimes);
    snapshot(src.PartyTimes._s_times, &dst->partyTimes.someOtherTimes);

    dst->position = src.pos.toInt();
    dst->viewYaw = src._viewYaw;
    dst->viewPitch = src._viewPitch;
    dst->prevPosition = src.lastPos.toInt();
    dst->viewPrevYaw = src._viewPrevYaw;
    dst->viewPrevPitch = src._viewPrevPitch;
    dst->prevEyeLevel = src.lastEyeLevel;
    dst->fallSpeed = src.velocity.z;
    dst->savedFlightZ = src.sPartySavedFlightZ;
    dst->waterLavaTimer = src._6FC_water_lava_timer.ticks(); // Can overflow and that's OK.
    dst->fallStartZ = src.uFallStartZ;
    dst->flying = src.bFlying;
    dst->field_708 = 15; // Vanilla set this to 15, so we're doing the same just in case.
    dst->hirelingScrollPosition = src.hirelingScrollPosition;
    dst->field_70A = src.cNonHireFollowers;
    dst->currentYear = src.uCurrentYear;
    dst->currentMonth = src.uCurrentMonth;
    dst->currentMonthWeek = src.uCurrentMonthWeek;
    dst->currentDayOfMonth = src.uCurrentDayOfMonth;
    dst->currentHour = src.uCurrentHour;
    dst->currentMinute = src.uCurrentMinute;
    dst->currentTimeSecond = src.uCurrentTimeSecond;
    dst->numFoodRations = src.GetFood();
    dst->numGold = src.GetGold();
    dst->numGoldInBank = src.uNumGoldInBank;
    dst->numDeaths = src.uNumDeaths;
    dst->numPrisonTerms = src.uNumPrisonTerms;
    dst->numBountiesCollected = src.uNumBountiesCollected;

    snapshot(src.monster_id_for_hunting, &dst->monsterIdForHunting);
    snapshot(src.monster_for_hunting_killed, &dst->monsterForHuntingKilled, tags::cast<bool, int16_t>);

    dst->daysPlayedWithoutRest = src.days_played_without_rest;

    snapshot(src._questBits, &dst->questBits, tags::reverseBits);
    snapshot(src.pArcomageWins, &dst->arcomageWins);

    // We can't save in arena, but doing proper serialization here anyway.
    if (src.arenaState == ARENA_STATE_INITIAL) {
        dst->field_7B5_in_arena_quest = 0;
    } else if (src.arenaState == ARENA_STATE_WON) {
        dst->field_7B5_in_arena_quest = -1;
    } else  {
        dst->field_7B5_in_arena_quest = std::to_underlying(dialogueForArenaLevel(src.arenaLevel));
    }

    snapshot(src.uNumArenaWins, &dst->numArenaWins);

    snapshot(src.pIsArtifactFound, &dst->isArtifactFound);
    snapshot(src._autonoteBits, &dst->autonoteBits, tags::reverseBits);

    dst->numArcomageWins = src.uNumArcomageWins;
    dst->numArcomageLoses = src.uNumArcomageLoses;
    dst->turnBasedModeOn = src.bTurnBasedModeOn;
    dst->flags2 = std::to_underlying(src.uFlags2);

    unsigned align = 0;
    if (src.alignment == PartyAlignment::PartyAlignment_Evil) align = 2;
    if (src.alignment == PartyAlignment::PartyAlignment_Neutral) align = 1;
    dst->alignment = align;

    snapshot(src.pPartyBuffs, &dst->partyBuffs);
    snapshot(src.pCharacters, &dst->players);
    snapshot(src.pHirelings, &dst->hirelings);

    // Vanilla stored NPC sacrifice status in NPC evt values.
    for (int i = 0; i < 2; i++) {
        if (src.pHirelingsSacrifice[i].inProgress) {
            dst->hirelings[i].evt_A = 1;
            dst->hirelings[i].evt_B = src.pHirelingsSacrifice[i].elapsedTime.ticks();
            dst->hirelings[i].evt_C = src.pHirelingsSacrifice[i].endTime.ticks();
        }
    }

    snapshot(src.pPickedItem, &dst->pickedItem, tags::context(ITEM_SLOT_INVALID));

    dst->flags = std::to_underlying(src.uFlags);

    dst->standartItemsInShop0.fill({});
    snapshot(src.standartItemsInShops, &dst->standartItemsInShops, tags::context(ITEM_SLOT_INVALID));
    dst->specialItemsInShop0.fill({});
    snapshot(src.specialItemsInShops, &dst->specialItemsInShops, tags::context(ITEM_SLOT_INVALID));
    snapshot(src.spellBooksInGuilds, &dst->spellBooksInGuilds, tags::context(ITEM_SLOT_INVALID));

    snapshot(src.pHireling1Name, &dst->hireling1Name);
    snapshot(src.pHireling2Name, &dst->hireling2Name);

    dst->armageddonTimer = src.armageddon_timer.ticks();
    dst->armageddonDamage = src.armageddonDamage;

    snapshot(src.pTurnBasedCharacterRecoveryTimes, &dst->turnBasedPlayerRecoveryTimes);
    snapshot(src.InTheShopFlags, &dst->inTheShopFlags);

    dst->fine = src.uFine;
}

void reconstruct(const Party_MM7 &src, Party *dst) {
    dst->Zero();

    dst->height = src.partyHeight;
    dst->eyeLevel = src.eyeLevel;
    dst->radius = src.radius;
    dst->_yawGranularity = src.yawGranularity;
    dst->walkSpeed = src.walkSpeed;
    dst->_yawRotationSpeed = src.yawRotationSpeed;
    dst->jump_strength = src.jumpStrength;
    reconstruct(src.timePlayed, &dst->playing_time);
    reconstruct(src.lastRegenerationTime, &dst->last_regenerated);

    reconstruct(src.partyTimes.bountyHuntingNextGenerationTime, &dst->PartyTimes.bountyHuntNextGenTime);
    reconstruct(src.partyTimes.shopsNextGenerationTime, &dst->PartyTimes.shopNextRefreshTime);
    reconstruct(src.partyTimes.guildsNextGenerationTime, &dst->PartyTimes.guildNextRefreshTime);
    reconstruct(src.partyTimes.shopBanTimes, &dst->PartyTimes.shopBanTimes);
    reconstruct(src.partyTimes.counterEventValues, &dst->PartyTimes.CounterEventValues);
    reconstruct(src.partyTimes.historyEventTimes, &dst->PartyTimes.HistoryEventTimes);
    reconstruct(src.partyTimes.someOtherTimes, &dst->PartyTimes._s_times);

    dst->pos = src.position.toFloat();
    dst->_viewYaw = src.viewYaw;
    dst->_viewPitch = src.viewPitch;
    dst->lastPos = src.prevPosition.toFloat();
    dst->_viewPrevYaw = src.viewPrevYaw;
    dst->_viewPrevPitch = src.viewPrevPitch;
    dst->lastEyeLevel = src.prevEyeLevel;
    dst->velocity = Vec3f(0, 0, src.fallSpeed);
    dst->sPartySavedFlightZ = src.savedFlightZ;
    dst->_6FC_water_lava_timer = Time::fromTicks(src.waterLavaTimer);
    dst->uFallStartZ = src.fallStartZ;
    dst->bFlying = src.flying;
    dst->hirelingScrollPosition = src.hirelingScrollPosition;
    dst->cNonHireFollowers = src.field_70A;
    dst->uCurrentYear = src.currentYear;
    dst->uCurrentMonth = src.currentMonth;
    dst->uCurrentMonthWeek = src.currentMonthWeek;
    dst->uCurrentDayOfMonth = src.currentDayOfMonth;
    dst->uCurrentHour = src.currentHour;
    dst->uCurrentMinute = src.currentMinute;
    dst->uCurrentTimeSecond = src.currentTimeSecond;
    dst->uNumFoodRations = src.numFoodRations;
    dst->uNumGold = src.numGold;
    dst->uNumGoldInBank = src.numGoldInBank;
    dst->uNumDeaths = src.numDeaths;
    dst->uNumPrisonTerms = src.numPrisonTerms;
    dst->uNumBountiesCollected = src.numBountiesCollected;

    reconstruct(src.monsterIdForHunting, &dst->monster_id_for_hunting);
    reconstruct(src.monsterForHuntingKilled, &dst->monster_for_hunting_killed, tags::cast<int16_t, bool>);

    dst->days_played_without_rest = src.daysPlayedWithoutRest;

    reconstruct(src.questBits, &dst->_questBits, tags::reverseBits);
    reconstruct(src.arcomageWins, &dst->pArcomageWins);

    // We can't save in arena, but doing proper deserialization here anyway.
    if (src.field_7B5_in_arena_quest == 0) {
        dst->arenaState = ARENA_STATE_INITIAL;
        dst->arenaLevel = ARENA_LEVEL_INVALID;
    } else if (src.field_7B5_in_arena_quest == -1) {
        dst->arenaState = ARENA_STATE_WON;
        dst->arenaLevel = ARENA_LEVEL_INVALID;
    } else  {
        dst->arenaState = ARENA_STATE_FIGHTING;
        dst->arenaLevel = arenaLevelForDialogue(static_cast<DialogueId>(src.field_7B5_in_arena_quest));
    }

    reconstruct(src.numArenaWins, &dst->uNumArenaWins);

    reconstruct(src.isArtifactFound, &dst->pIsArtifactFound);
    reconstruct(src.autonoteBits, &dst->_autonoteBits, tags::reverseBits);

    dst->uNumArcomageWins = src.numArcomageWins;
    dst->uNumArcomageLoses = src.numArcomageLoses;
    dst->bTurnBasedModeOn = src.turnBasedModeOn;
    dst->uFlags2 = static_cast<PARTY_FLAGS_2>(src.flags2);

    switch (src.alignment) {
        case 0:
            dst->alignment = PartyAlignment::PartyAlignment_Good;
            break;
        case 1:
            dst->alignment = PartyAlignment::PartyAlignment_Neutral;
            break;
        case 2:
            dst->alignment = PartyAlignment::PartyAlignment_Evil;
            break;
        default:
            assert(false);
    }

    reconstruct(src.partyBuffs, &dst->pPartyBuffs);
    for (int i = 0; i < 4; i++)
        reconstruct(src.players[i], &dst->pCharacters[i], tags::context(i));
    reconstruct(src.hirelings, &dst->pHirelings);

    // Vanilla stored NPC sacrifice status in NPC evt values.
    for (int i = 0; i < 2; i++) {
        if (src.hirelings[i].evt_A) {
            dst->pHirelings[i].dialogue_1_evt_id = 0;
            dst->pHirelings[i].dialogue_2_evt_id = 0;
            dst->pHirelings[i].dialogue_3_evt_id = 0;
            dst->pHirelingsSacrifice[i].inProgress = true;
            dst->pHirelingsSacrifice[i].elapsedTime = Duration::fromTicks(src.hirelings[i].evt_B);
            dst->pHirelingsSacrifice[i].endTime = Duration::fromTicks(src.hirelings[i].evt_C);
        }
    }

    reconstruct(src.pickedItem, &dst->pPickedItem);

    dst->uFlags = static_cast<PartyFlags>(src.flags);

    reconstruct(src.standartItemsInShops, &dst->standartItemsInShops);
    reconstruct(src.specialItemsInShops, &dst->specialItemsInShops);
    reconstruct(src.spellBooksInGuilds, &dst->spellBooksInGuilds);

    reconstruct(src.hireling1Name, &dst->pHireling1Name);
    reconstruct(src.hireling2Name, &dst->pHireling2Name);

    dst->armageddon_timer = Duration::fromTicks(src.armageddonTimer);
    dst->armageddonDamage = src.armageddonDamage;

    reconstruct(src.turnBasedPlayerRecoveryTimes, &dst->pTurnBasedCharacterRecoveryTimes);
    reconstruct(src.inTheShopFlags, &dst->InTheShopFlags);

    dst->uFine = src.fine;
}

void snapshot(const CharacterConditions &src, CharacterConditions_MM7 *dst) {
    memzero(dst);

    snapshot(src._times, &dst->times);
}

void reconstruct(const CharacterConditions_MM7 &src, CharacterConditions *dst) {
    reconstruct(src.times, &dst->_times);
}

void snapshot(const Character &src, Character_MM7 *dst) {
    memzero(dst);

    snapshot(src.conditions, &dst->conditions);

    dst->experience = src.experience;

    snapshot(src.name, &dst->name);

    dst->sex = std::to_underlying(src.uSex);
    dst->classType = std::to_underlying(src.classType);
    dst->currentFace = src.uCurrentFace;
    dst->might = src._stats[ATTRIBUTE_MIGHT];
    dst->mightBonus = src._statBonuses[ATTRIBUTE_MIGHT];
    dst->intelligence = src._stats[ATTRIBUTE_INTELLIGENCE];
    dst->intelligenceBonus = src._statBonuses[ATTRIBUTE_INTELLIGENCE];
    dst->personality = src._stats[ATTRIBUTE_PERSONALITY];
    dst->personalityBonus = src._statBonuses[ATTRIBUTE_PERSONALITY];
    dst->endurance = src._stats[ATTRIBUTE_ENDURANCE];
    dst->enduranceBonus = src._statBonuses[ATTRIBUTE_ENDURANCE];
    dst->speed = src._stats[ATTRIBUTE_SPEED];
    dst->speedBonus = src._statBonuses[ATTRIBUTE_SPEED];
    dst->accuracy = src._stats[ATTRIBUTE_ACCURACY];
    dst->accuracyBonus = src._statBonuses[ATTRIBUTE_ACCURACY];
    dst->luck = src._stats[ATTRIBUTE_LUCK];
    dst->luckBonus = src._statBonuses[ATTRIBUTE_LUCK];
    dst->acModifier = src.sACModifier;
    dst->level = src.uLevel;
    dst->levelModifier = src.sLevelModifier;
    dst->ageModifier = src.sAgeModifier;

    snapshot(src.pActiveSkills, &dst->activeSkills, tags::segment<SKILL_FIRST_VISIBLE, SKILL_LAST_VISIBLE>);
    snapshot(src._achievedAwardsBits, &dst->achievedAwardsBits, tags::reverseBits);
    snapshot(src.bHaveSpell, &dst->haveSpell);

    dst->pureLuckUsed = src._pureStatPotionUsed[ATTRIBUTE_LUCK];
    dst->pureSpeedUsed = src._pureStatPotionUsed[ATTRIBUTE_SPEED];
    dst->pureIntellectUsed = src._pureStatPotionUsed[ATTRIBUTE_INTELLIGENCE];
    dst->pureEnduranceUsed = src._pureStatPotionUsed[ATTRIBUTE_ENDURANCE];
    dst->purePersonalityUsed = src._pureStatPotionUsed[ATTRIBUTE_PERSONALITY];
    dst->pureAccuracyUsed = src._pureStatPotionUsed[ATTRIBUTE_ACCURACY];
    dst->pureMightUsed = src._pureStatPotionUsed[ATTRIBUTE_MIGHT];

    snapshot(src.inventory, dst);

    dst->resFireBase = src.sResFireBase;
    dst->resAirBase = src.sResAirBase;
    dst->resWaterBase = src.sResWaterBase;
    dst->resEarthBase = src.sResEarthBase;
    dst->resPhysicalBase = src.sResPhysicalBase;
    dst->resMagicBase = src.sResMagicBase;
    dst->resSpiritBase = src.sResSpiritBase;
    dst->resMindBase = src.sResMindBase;
    dst->resBodyBase = src.sResBodyBase;
    dst->resLightBase = src.sResLightBase;
    dst->resDarkBase = src.sResDarkBase;
    dst->resFireBonus = src.sResFireBonus;
    dst->resAirBonus = src.sResAirBonus;
    dst->resWaterBonus = src.sResWaterBonus;
    dst->resEarthBonus = src.sResEarthBonus;
    dst->resPhysicalBonus = src.sResPhysicalBonus;
    dst->resMagicBonus = src.sResMagicBonus;
    dst->resSpiritBonus = src.sResSpiritBonus;
    dst->resMindBonus = src.sResMindBonus;
    dst->resBodyBonus = src.sResBodyBonus;
    dst->resLightBonus = src.sResLightBonus;
    dst->resDarkBonus = src.sResDarkBonus;

    snapshot(src.pCharacterBuffs, &dst->playerBuffs);

    dst->voiceId = src.uVoiceID;
    dst->prevVoiceId = src.uPrevVoiceID;
    dst->prevFace = src.uPrevFace;
    dst->timeToRecovery = src.timeToRecovery.ticks();
    dst->skillPoints = src.uSkillPoints;
    dst->health = src.health;
    dst->mana = src.mana;
    dst->birthYear = src.uBirthYear;

    dst->lastOpenedSpellbookPage = std::to_underlying(src.lastOpenedSpellbookPage);
    dst->quickSpell = std::to_underlying(src.uQuickSpell);

    snapshot(src._characterEventBits, &dst->playerEventBits, tags::reverseBits);

    dst->someAttackBonus = src._some_attack_bonus;
    dst->meleeDmgBonus = src._melee_dmg_bonus;
    dst->rangedAttackBonus = src._ranged_atk_bonus;
    dst->rangedDmgBonus = src._ranged_dmg_bonus;
    dst->fullHealthBonus = src.uFullHealthBonus;
    dst->healthRelated = src._health_related;
    dst->fullManaBonus = src.uFullManaBonus;
    dst->manaRelated = src._mana_related;
    dst->portrait = std::to_underlying(src.portrait);
    dst->portraitTimePassed = src.portraitTimePassed.ticks();
    dst->portraitTimeLength = src.portraitTimeLength.ticks();
    dst->portraitImageIndex = src.portraitImageIndex;
    dst->talkAnimTime = 0;
    dst->talkFrameSet = 0;

    for (unsigned int i = 0; i < 5; ++i) {
        if (!src.vBeacons[i]) {
            continue;
        }
        snapshot(src.vBeacons[i]->uBeaconTime, &dst->installedBeacons[i].beaconTime);
        dst->installedBeacons[i].partyPosX = src.vBeacons[i]->_partyPos.x;
        dst->installedBeacons[i].partyPosY = src.vBeacons[i]->_partyPos.y;
        dst->installedBeacons[i].partyPosZ = src.vBeacons[i]->_partyPos.z;
        dst->installedBeacons[i].partyViewYaw = src.vBeacons[i]->_partyViewYaw;
        dst->installedBeacons[i].partyViewPitch = src.vBeacons[i]->_partyViewPitch;
        dst->installedBeacons[i].mapIndexInGamesLod = valueOr(gamesLodIndexByMapId, src.vBeacons[i]->mapId, -1);
    }

    dst->numDivineInterventionCasts = src.uNumDivineInterventionCastsThisDay;
    dst->numArmageddonCasts = src.uNumArmageddonCasts;
    dst->numFireSpikeCasts = src.uNumFireSpikeCasts;
}

void reconstruct(const Character_MM7 &src, Character *dst, ContextTag<int> characterIndex) {
    dst->Zero();
    reconstruct(src.conditions, &dst->conditions);

    dst->experience = src.experience;

    reconstruct(src.name, &dst->name);

    switch (src.sex) {
    case 0:
        dst->uSex = SEX_MALE;
        break;
    case 1:
        dst->uSex = SEX_FEMALE;
        break;
    default:
        assert(false);
    }

    switch (src.classType) {
    case 0:
        dst->classType = CLASS_KNIGHT;
        break;
    case 1:
        dst->classType = CLASS_CAVALIER;
        break;
    case 2:
        dst->classType = CLASS_CHAMPION;
        break;
    case 3:
        dst->classType = CLASS_BLACK_KNIGHT;
        break;
    case 4:
        dst->classType = CLASS_THIEF;
        break;
    case 5:
        dst->classType = CLASS_ROGUE;
        break;
    case 6:
        dst->classType = CLASS_SPY;
        break;
    case 7:
        dst->classType = CLASS_ASSASSIN;
        break;
    case 8:
        dst->classType = CLASS_MONK;
        break;
    case 9:
        dst->classType = CLASS_INITIATE;
        break;
    case 10:
        dst->classType = CLASS_MASTER;
        break;
    case 11:
        dst->classType = CLASS_NINJA;
        break;
    case 12:
        dst->classType = CLASS_PALADIN;
        break;
    case 13:
        dst->classType = CLASS_CRUSADER;
        break;
    case 14:
        dst->classType = CLASS_HERO;
        break;
    case 15:
        dst->classType = CLASS_VILLIAN;
        break;
    case 16:
        dst->classType = CLASS_ARCHER;
        break;
    case 17:
        dst->classType = CLASS_WARRIOR_MAGE;
        break;
    case 18:
        dst->classType = CLASS_MASTER_ARCHER;
        break;
    case 19:
        dst->classType = CLASS_SNIPER;
        break;
    case 20:
        dst->classType = CLASS_RANGER;
        break;
    case 21:
        dst->classType = CLASS_HUNTER;
        break;
    case 22:
        dst->classType = CLASS_RANGER_LORD;
        break;
    case 23:
        dst->classType = CLASS_BOUNTY_HUNTER;
        break;
    case 24:
        dst->classType = CLASS_CLERIC;
        break;
    case 25:
        dst->classType = CLASS_PRIEST;
        break;
    case 26:
        dst->classType = CLASS_PRIEST_OF_SUN;
        break;
    case 27:
        dst->classType = CLASS_PRIEST_OF_MOON;
        break;
    case 28:
        dst->classType = CLASS_DRUID;
        break;
    case 29:
        dst->classType = CLASS_GREAT_DRUID;
        break;
    case 30:
        dst->classType = CLASS_ARCH_DRUID;
        break;
    case 31:
        dst->classType = CLASS_WARLOCK;
        break;
    case 32:
        dst->classType = CLASS_SORCERER;
        break;
    case 33:
        dst->classType = CLASS_WIZARD;
        break;
    case 34:
        dst->classType = CLASS_ARCHAMGE;
        break;
    case 35:
        dst->classType = CLASS_LICH;
        break;
    default:
        assert(false);
    }

    dst->uCurrentFace = src.currentFace;
    dst->_stats[ATTRIBUTE_MIGHT] = src.might;
    dst->_statBonuses[ATTRIBUTE_MIGHT] = src.mightBonus;
    dst->_stats[ATTRIBUTE_INTELLIGENCE] = src.intelligence;
    dst->_statBonuses[ATTRIBUTE_INTELLIGENCE] = src.intelligenceBonus;
    dst->_stats[ATTRIBUTE_PERSONALITY] = src.personality;
    dst->_statBonuses[ATTRIBUTE_PERSONALITY] = src.personalityBonus;
    dst->_stats[ATTRIBUTE_ENDURANCE] = src.endurance;
    dst->_statBonuses[ATTRIBUTE_ENDURANCE] = src.enduranceBonus;
    dst->_stats[ATTRIBUTE_SPEED] = src.speed;
    dst->_statBonuses[ATTRIBUTE_SPEED] = src.speedBonus;
    dst->_stats[ATTRIBUTE_ACCURACY] = src.accuracy;
    dst->_statBonuses[ATTRIBUTE_ACCURACY] = src.accuracyBonus;
    dst->_stats[ATTRIBUTE_LUCK] = src.luck;
    dst->_statBonuses[ATTRIBUTE_LUCK] = src.luckBonus;
    dst->sACModifier = src.acModifier;
    dst->uLevel = src.level;
    dst->sLevelModifier = src.levelModifier;
    dst->sAgeModifier = src.ageModifier;

    reconstruct(src.activeSkills, &dst->pActiveSkills, tags::segment<SKILL_FIRST_VISIBLE, SKILL_LAST_VISIBLE>);
    reconstruct(src.achievedAwardsBits, &dst->_achievedAwardsBits, tags::reverseBits);
    reconstruct(src.haveSpell, &dst->bHaveSpell);

    dst->_pureStatPotionUsed[ATTRIBUTE_LUCK] = src.pureLuckUsed;
    dst->_pureStatPotionUsed[ATTRIBUTE_SPEED] = src.pureSpeedUsed;
    dst->_pureStatPotionUsed[ATTRIBUTE_INTELLIGENCE] = src.pureIntellectUsed;
    dst->_pureStatPotionUsed[ATTRIBUTE_ENDURANCE] = src.pureEnduranceUsed;
    dst->_pureStatPotionUsed[ATTRIBUTE_PERSONALITY] = src.purePersonalityUsed;
    dst->_pureStatPotionUsed[ATTRIBUTE_ACCURACY] = src.pureAccuracyUsed;
    dst->_pureStatPotionUsed[ATTRIBUTE_MIGHT] = src.pureMightUsed;

    reconstruct(src, &dst->inventory, characterIndex);

    dst->sResFireBase = src.resFireBase;
    dst->sResAirBase = src.resAirBase;
    dst->sResWaterBase = src.resWaterBase;
    dst->sResEarthBase = src.resEarthBase;
    dst->sResPhysicalBase = src.resPhysicalBase;
    dst->sResMagicBase = src.resMagicBase;
    dst->sResSpiritBase = src.resSpiritBase;
    dst->sResMindBase = src.resMindBase;
    dst->sResBodyBase = src.resBodyBase;
    dst->sResLightBase = src.resLightBase;
    dst->sResDarkBase = src.resDarkBase;
    dst->sResFireBonus = src.resFireBonus;
    dst->sResAirBonus = src.resAirBonus;
    dst->sResWaterBonus = src.resWaterBonus;
    dst->sResEarthBonus = src.resEarthBonus;
    dst->sResPhysicalBonus = src.resPhysicalBonus;
    dst->sResMagicBonus = src.resMagicBonus;
    dst->sResSpiritBonus = src.resSpiritBonus;
    dst->sResMindBonus = src.resMindBonus;
    dst->sResBodyBonus = src.resBodyBonus;
    dst->sResLightBonus = src.resLightBonus;
    dst->sResDarkBonus = src.resDarkBonus;

    reconstruct(src.playerBuffs, &dst->pCharacterBuffs);

    dst->uVoiceID = src.voiceId;
    dst->uPrevVoiceID = src.prevVoiceId;
    dst->uPrevFace = src.prevFace;
    dst->timeToRecovery = Duration::fromTicks(src.timeToRecovery);
    dst->uSkillPoints = src.skillPoints;
    dst->health = src.health;
    dst->mana = src.mana;
    dst->uBirthYear = src.birthYear;

    dst->lastOpenedSpellbookPage = static_cast<MagicSchool>(src.lastOpenedSpellbookPage);
    dst->uQuickSpell = static_cast<SpellId>(src.quickSpell);

    reconstruct(src.playerEventBits, &dst->_characterEventBits, tags::reverseBits);

    dst->_some_attack_bonus = src.someAttackBonus;
    dst->_melee_dmg_bonus = src.meleeDmgBonus;
    dst->_ranged_atk_bonus = src.rangedAttackBonus;
    dst->_ranged_dmg_bonus = src.rangedDmgBonus;
    dst->uFullHealthBonus = src.fullHealthBonus;
    dst->_health_related = src.healthRelated;
    dst->uFullManaBonus = src.fullManaBonus;
    dst->_mana_related = src.manaRelated;
    dst->portrait = static_cast<PortraitId>(src.portrait);
    dst->portraitTimePassed = Duration::fromTicks(src.portraitTimePassed);
    dst->portraitTimeLength = Duration::fromTicks(src.portraitTimeLength);
    dst->portraitImageIndex = src.portraitImageIndex;
    dst->talkAnimation = TalkAnimation();

    for (int z = 0; z < 5; z++) {
        if (dst->vBeacons[z])
            dst->vBeacons[z]->image->release();
        dst->vBeacons[z].reset();
    }

    for (unsigned int i = 0; i < 5; ++i) {
        if (src.installedBeacons[i].beaconTime != 0) {
            LloydBeacon beacon;
            beacon.uBeaconTime = Time::fromTicks(src.installedBeacons[i].beaconTime);
            beacon._partyPos.x = src.installedBeacons[i].partyPosX;
            beacon._partyPos.y = src.installedBeacons[i].partyPosY;
            beacon._partyPos.z = src.installedBeacons[i].partyPosZ;
            beacon._partyViewYaw = src.installedBeacons[i].partyViewYaw;
            beacon._partyViewPitch = src.installedBeacons[i].partyViewPitch;
            beacon.mapId = valueOr(mapIdByGamesLodIndex, src.installedBeacons[i].mapIndexInGamesLod, MAP_INVALID);
            dst->vBeacons[i] = beacon;
        }
    }

    dst->uNumDivineInterventionCastsThisDay = src.numDivineInterventionCasts;
    dst->uNumArmageddonCasts = src.numArmageddonCasts;
    dst->uNumFireSpikeCasts = src.numFireSpikeCasts;
}

void snapshot(const CharacterInventory &src, Character_MM7 *dst) {
    for (size_t i = 0; i < 126; i++)
        snapshot(src._records[i].item, &dst->inventoryItems[i], tags::context(src._records[i].slot));
    for (size_t i = 0; i < 126; i++)
        dst->inventoryMatrix[i] = src._grid[i];

    snapshot(src._equipment, &dst->equipment, tags::cast<int, uint32_t>);
    for (ItemSlot slot : allItemSlots())
        if (InventoryConstEntry entry = src.entry(slot))
            dst->inventoryItems[entry.index()].equippedSlot = std::to_underlying(slot);
}

void reconstruct(const Character_MM7 &src, CharacterInventory *dst, ContextTag<int> characterIndex) {
    *dst = CharacterInventory();

    std::array<bool, 126> processed = {{}};
    std::array<bool, 126> pending = {{}};
    std::array<Item, 126> items;
    reconstruct(src.inventoryItems, &items);

    // Serialized character inventory can be quite broken, so we just check pretty much everything there is to check,
    // and just log errors.

    Sizei size = dst->gridSize();
    int maxIndex = size.w * size.h;
    for (int x = 0; x < size.w; x++) {
        for (int y = 0; y < size.h; y++) {
            int index = src.inventoryMatrix[x + y * size.w];
            if (index <= 0)
                continue;
            index--;

            if (index > maxIndex) {
                logger->warning("Invalid item reference in backpack for character #{}, itemId={}, index={}, pos=({},{})",
                                *characterIndex, std::to_underlying(items[index].itemId), index, x, y);
                continue;
            }

            if (items[index].itemId == ITEM_NULL) {
                logger->warning("Null item in backpack for character #{}, itemId={}, index={}, pos=({},{})",
                                *characterIndex, std::to_underlying(items[index].itemId), index, x, y);
                continue;
            }

            if (processed[index]) {
                logger->warning("Duplicate item in backpack for character #{}, itemId={}, index={}, pos=({},{})",
                                *characterIndex, std::to_underlying(items[index].itemId), index, x, y);
                continue;
            }

            if (dst->canAdd({x, y}, items[index])) {
                processed[index] = true;
                dst->addAt({x, y}, items[index], index); // We need to preserve item indices.
            } else {
                pending[index] = true;
                logger->warning("Overlapping item in backpack for character #{}, itemId={}, index={}, pos=({},{})",
                                *characterIndex, std::to_underlying(items[index].itemId), index, x, y);
            }
        }
    }

    for (ItemSlot slot : allItemSlots()) {
        int index = src.equipment[std::to_underlying(slot) - std::to_underlying(ITEM_SLOT_FIRST_VALID)];
        if (index <= 0)
            continue;
        index--;

        if (index > maxIndex) {
            logger->warning("Invalid item reference in equipment for character #{}, itemId={}, index={}, slot={}",
                            *characterIndex, std::to_underlying(items[index].itemId), index, std::to_underlying(slot));
            continue;
        }

        if (items[index].itemId == ITEM_NULL) {
            logger->warning("Null item in equipment for character #{}, itemId={}, index={}, slot={}",
                            *characterIndex, std::to_underlying(items[index].itemId), index, std::to_underlying(slot));
            continue;
        }

        if (processed[index]) {
            logger->warning("Duplicate item in equipment for character #{}, itemId={}, index={}, slot={}",
                            *characterIndex, std::to_underlying(items[index].itemId), index, std::to_underlying(slot));
            continue;
        }

        if (dst->canEquip(slot)) {
            processed[index] = true;
            dst->equipAt(slot, items[index], index); // We need to preserve item indices.
        } else {
            pending[index] = true;
            logger->warning("Overlapping items in equipment for character #{}, itemId={}, index={}, slot={}",
                            *characterIndex, std::to_underlying(items[index].itemId), index, std::to_underlying(slot));
        }
    }

    for (size_t index = 0; index < items.size(); index++) {
        if (processed[index] || items[index].itemId == ITEM_NULL)
            continue;

        if (!pending[index]) {
            logger->warning("Invisible item was dropped from inventory for character #{}, itemId={}, index={}",
                            *characterIndex, std::to_underlying(items[index].itemId), index);
        } else if (std::optional<Pointi> pos = dst->findSpace(items[index])) {
            dst->addAt(*pos, items[index], index);
        } else {
            logger->warning("Overlapping item was dropped from inventory for character #{}, itemId={}, index={}",
                            *characterIndex, std::to_underlying(items[index].itemId), index);
        }
    }
}

void snapshot(const IconFrameData &src, IconFrameData_MM7 *dst) {
    memzero(dst);

    snapshot(src.animationName, &dst->animationName);
    dst->animationLength = src.animationLength.ticks() / 8;
    snapshot(src.textureName, &dst->textureName);
    dst->frameLength = src.frameLength.ticks() / 8;
    dst->flags = std::to_underlying(src.flags);
}

void reconstruct(const IconFrameData_MM7 &src, IconFrameData *dst) {
    reconstruct(src.animationName, &dst->animationName);
    dst->animationLength = Duration::fromTicks(8 * src.animationLength);
    reconstruct(src.textureName, &dst->textureName);
    dst->frameLength = Duration::fromTicks(8 * src.frameLength);
    dst->flags = static_cast<FrameFlags>(src.flags);
}

void reconstruct(const MonsterDesc_MM6 &src, MonsterDesc *dst) {
    dst->monsterHeight = src.monsterHeight;
    dst->monsterRadius = src.monsterRadius;
    dst->movementSpeed = src.movementSpeed;
    dst->toHitRadius = src.toHitRadius;
    dst->tintColor = colorTable.White;
    reconstruct(src.soundSampleIds, &dst->soundSampleIds, tags::cast<uint16_t, SoundId>);
    reconstruct(src.internalMonsterName, &dst->internalMonsterName);
    reconstruct(src.spriteNames, &dst->spriteNames);
}

void snapshot(const MonsterDesc &src, MonsterDesc_MM7 *dst) {
    memzero(dst);

    dst->monsterHeight = src.monsterHeight;
    dst->monsterRadius = src.monsterRadius;
    dst->movementSpeed = src.movementSpeed;
    dst->toHitRadius = src.toHitRadius;
    dst->tintColor = src.tintColor.c32();
    snapshot(src.soundSampleIds, &dst->soundSampleIds, tags::cast<SoundId, uint16_t>);
    snapshot(src.internalMonsterName, &dst->internalMonsterName);
    snapshot(src.spriteNames, &dst->spriteNames);
    dst->spriteNamesUnused[0].fill('\0');
    dst->spriteNamesUnused[1].fill('\0');
}

void reconstruct(const MonsterDesc_MM7 &src, MonsterDesc *dst) {
    dst->monsterHeight = src.monsterHeight;
    dst->monsterRadius = src.monsterRadius;
    dst->movementSpeed = src.movementSpeed;
    dst->toHitRadius = src.toHitRadius;
    dst->tintColor = Color::fromC32(src.tintColor);
    reconstruct(src.soundSampleIds, &dst->soundSampleIds, tags::cast<uint16_t, SoundId>);
    reconstruct(src.internalMonsterName, &dst->internalMonsterName);
    reconstruct(src.spriteNames, &dst->spriteNames);
}

void snapshot(const ActorJob &src, ActorJob_MM7 *dst) {
    memzero(dst);

    snapshot(src.vPos, &dst->pos);
    dst->attributes = src.uAttributes;
    dst->action = src.uAction;
    dst->hour = src.uHour;
    dst->day = src.uDay;
    dst->month = src.uMonth;
}

void reconstruct(const ActorJob_MM7 &src, ActorJob *dst) {
    reconstruct(src.pos, &dst->vPos);
    dst->uAttributes = src.attributes;
    dst->uAction = src.action;
    dst->uHour = src.hour;
    dst->uDay = src.day;
    dst->uMonth = src.month;
}

void snapshot(const Actor &src, Actor_MM7 *dst) {
    memzero(dst);

    snapshot(src.name, &dst->name);

    dst->npcId = src.npcId;
    dst->attributes = std::to_underlying(src.attributes);
    dst->hp = src.hp;

    dst->monsterInfo.level = src.monsterInfo.level;
    dst->monsterInfo.treasureDropChance = src.monsterInfo.treasureDropChance;
    dst->monsterInfo.goldDiceRolls = src.monsterInfo.goldDiceRolls;
    dst->monsterInfo.goldDiceSides = src.monsterInfo.goldDiceSides;
    dst->monsterInfo.treasureLevel = std::to_underlying(src.monsterInfo.treasureLevel);
    dst->monsterInfo.treasureType = std::to_underlying(src.monsterInfo.treasureType);
    dst->monsterInfo.flying = src.monsterInfo.flying;
    dst->monsterInfo.movementType = std::to_underlying(src.monsterInfo.movementType);
    dst->monsterInfo.aiType = std::to_underlying(src.monsterInfo.aiType);
    dst->monsterInfo.hostilityType = std::to_underlying(src.monsterInfo.hostilityType);
    dst->monsterInfo.specialAttackType = std::to_underlying(src.monsterInfo.specialAttackType);
    dst->monsterInfo.specialAttackLevel = src.monsterInfo.specialAttackLevel;
    dst->monsterInfo.attack1Type = std::to_underlying(src.monsterInfo.attack1Type);
    dst->monsterInfo.attack1DamageDiceRolls = src.monsterInfo.attack1DamageDiceRolls;
    dst->monsterInfo.attack1DamageDiceSides = src.monsterInfo.attack1DamageDiceSides;
    dst->monsterInfo.attack1DamageBonus = src.monsterInfo.attack1DamageBonus;
    dst->monsterInfo.attack1MissileType = std::to_underlying(src.monsterInfo.attack1MissileType);
    dst->monsterInfo.attack2Chance = src.monsterInfo.attack2Chance;
    dst->monsterInfo.attack2Type = std::to_underlying(src.monsterInfo.attack2Type);
    dst->monsterInfo.attack2DamageDiceRolls = src.monsterInfo.attack2DamageDiceRolls;
    dst->monsterInfo.attack2DamageDiceSides = src.monsterInfo.attack2DamageDiceSides;
    dst->monsterInfo.attack2DamageBonus = src.monsterInfo.attack2DamageBonus;
    dst->monsterInfo.attack2MissileType = std::to_underlying(src.monsterInfo.attack2MissileType);
    dst->monsterInfo.spell1UseChance = src.monsterInfo.spell1UseChance;
    dst->monsterInfo.spell1Id = std::to_underlying(src.monsterInfo.spell1Id);
    dst->monsterInfo.spell2UseChance = src.monsterInfo.spell2UseChance;
    dst->monsterInfo.spell2Id = std::to_underlying(src.monsterInfo.spell2Id);
    dst->monsterInfo.resFire = src.monsterInfo.resFire;
    dst->monsterInfo.resAir = src.monsterInfo.resAir;
    dst->monsterInfo.resWater = src.monsterInfo.resWater;
    dst->monsterInfo.resEarth = src.monsterInfo.resEarth;
    dst->monsterInfo.resMind = src.monsterInfo.resMind;
    dst->monsterInfo.resSpirit = src.monsterInfo.resSpirit;
    dst->monsterInfo.resBody = src.monsterInfo.resBody;
    dst->monsterInfo.resLight = src.monsterInfo.resLight;
    dst->monsterInfo.resDark = src.monsterInfo.resDark;
    dst->monsterInfo.resPhysical = src.monsterInfo.resPhysical;
    dst->monsterInfo.specialAbilityType = std::to_underlying(src.monsterInfo.specialAbilityType);
    dst->monsterInfo.specialAbilityDamageDiceRolls = src.monsterInfo.specialAbilityDamageDiceRolls;
    dst->monsterInfo.specialAbilityDamageDiceSides = src.monsterInfo.specialAbilityDamageDiceSides;
    dst->monsterInfo.specialAbilityDamageDiceBonus = src.monsterInfo.specialAbilityDamageDiceBonus;
    dst->monsterInfo.numCharactersAttackedPerSpecialAbility = src.monsterInfo.numCharactersAttackedPerSpecialAbility;
    dst->monsterInfo.id = std::to_underlying(src.monsterInfo.id);
    dst->monsterInfo.bloodSplatOnDeath = src.monsterInfo.bloodSplatOnDeath;
    snapshot(src.monsterInfo.spell1SkillMastery, &dst->monsterInfo.spell1SkillMastery);
    snapshot(src.monsterInfo.spell2SkillMastery, &dst->monsterInfo.spell2SkillMastery);
    dst->monsterInfo.field_3C_some_special_attack = src.monsterInfo.field_3C_some_special_attack;
    dst->monsterInfo.field_3E = src.monsterInfo.field_3E;
    dst->monsterInfo.hp = src.monsterInfo.hp;
    dst->monsterInfo.ac = src.monsterInfo.ac;
    dst->monsterInfo.exp = src.monsterInfo.exp;
    dst->monsterInfo.baseSpeed = src.monsterInfo.baseSpeed;
    dst->monsterInfo.recoveryTime = src.monsterInfo.recoveryTime.ticks();
    dst->monsterInfo.attackPreferences = std::to_underlying(src.monsterInfo.attackPreferences);
    dst->monsterId = std::to_underlying(src.monsterId);
    dst->radius = src.radius;
    dst->height = src.height;
    dst->moveSpeed = src.moveSpeed;
    snapshot(src.pos, &dst->pos);
    snapshot(src.velocity, &dst->velocity);
    dst->yawAngle = src.yawAngle;
    dst->pitchAngle = src.pitchAngle;
    dst->sectorId = src.sectorId;
    dst->currentActionLength = src.currentActionLength.ticks();
    snapshot(src.initialPosition, &dst->initialPosition);
    snapshot(src.guardingPosition, &dst->guardingPosition);
    dst->tetherDistance = src.tetherDistance;
    dst->aiState = std::to_underlying(src.aiState);
    dst->currentActionAnimation = std::to_underlying(src.currentActionAnimation);
    dst->carriedItemId = std::to_underlying(src.carriedItemId);
    dst->currentActionTime = src.currentActionTime.ticks();

    snapshot(src.spriteIds, &dst->spriteIds);
    snapshot(src.soundSampleIds, &dst->soundSampleIds, tags::cast<SoundId, uint16_t>);
    snapshot(src.buffs, &dst->buffs);
    snapshot(src.items, &dst->items, tags::context(ITEM_SLOT_INVALID));

    dst->group = src.group;
    dst->ally = std::to_underlying(src.ally);

    snapshot(src.scheduledJobs, &dst->scheduledJobs);

    dst->summonerId = src.summonerId.packed();
    dst->lastCharacterIdToHit = src.lastCharacterIdToHit.packed();
    dst->uniqueNameIndex = src.uniqueNameIndex;
}

void reconstruct(const Actor_MM7 &src, Actor *dst) {
    reconstruct(src.name, &dst->name);
    dst->npcId = src.npcId;
    dst->attributes = ActorAttributes(src.attributes);
    dst->hp = src.hp;

    dst->monsterInfo.level = src.monsterInfo.level;
    dst->monsterInfo.treasureDropChance = src.monsterInfo.treasureDropChance;
    dst->monsterInfo.goldDiceRolls = src.monsterInfo.goldDiceRolls;
    dst->monsterInfo.goldDiceSides = src.monsterInfo.goldDiceSides;
    dst->monsterInfo.treasureLevel = static_cast<ItemTreasureLevel>(src.monsterInfo.treasureLevel);
    dst->monsterInfo.treasureType = static_cast<RandomItemType>(src.monsterInfo.treasureType);
    dst->monsterInfo.flying = src.monsterInfo.flying;
    dst->monsterInfo.movementType = static_cast<MonsterMovementType>(src.monsterInfo.movementType);
    dst->monsterInfo.aiType = static_cast<MonsterAiType>(src.monsterInfo.aiType);
    dst->monsterInfo.hostilityType = static_cast<MonsterHostility>(src.monsterInfo.hostilityType);
    dst->monsterInfo.specialAttackType = static_cast<MonsterSpecialAttack>(src.monsterInfo.specialAttackType);
    dst->monsterInfo.specialAttackLevel = src.monsterInfo.specialAttackLevel;
    dst->monsterInfo.attack1Type = static_cast<DamageType>(src.monsterInfo.attack1Type);
    dst->monsterInfo.attack1DamageDiceRolls = src.monsterInfo.attack1DamageDiceRolls;
    dst->monsterInfo.attack1DamageDiceSides = src.monsterInfo.attack1DamageDiceSides;
    dst->monsterInfo.attack1DamageBonus = src.monsterInfo.attack1DamageBonus;
    dst->monsterInfo.attack1MissileType = static_cast<MonsterProjectile>(src.monsterInfo.attack1MissileType);
    dst->monsterInfo.attack2Chance = src.monsterInfo.attack2Chance;
    dst->monsterInfo.attack2Type = static_cast<DamageType>(src.monsterInfo.attack2Type);
    dst->monsterInfo.attack2DamageDiceRolls = src.monsterInfo.attack2DamageDiceRolls;
    dst->monsterInfo.attack2DamageDiceSides = src.monsterInfo.attack2DamageDiceSides;
    dst->monsterInfo.attack2DamageBonus = src.monsterInfo.attack2DamageBonus;
    dst->monsterInfo.attack2MissileType = static_cast<MonsterProjectile>(src.monsterInfo.attack2MissileType);
    dst->monsterInfo.spell1UseChance = src.monsterInfo.spell1UseChance;
    dst->monsterInfo.spell1Id = static_cast<SpellId>(src.monsterInfo.spell1Id);
    dst->monsterInfo.spell2UseChance = src.monsterInfo.spell2UseChance;
    dst->monsterInfo.spell2Id = static_cast<SpellId>(src.monsterInfo.spell2Id);
    dst->monsterInfo.resFire = src.monsterInfo.resFire;
    dst->monsterInfo.resAir = src.monsterInfo.resAir;
    dst->monsterInfo.resWater = src.monsterInfo.resWater;
    dst->monsterInfo.resEarth = src.monsterInfo.resEarth;
    dst->monsterInfo.resMind = src.monsterInfo.resMind;
    dst->monsterInfo.resSpirit = src.monsterInfo.resSpirit;
    dst->monsterInfo.resBody = src.monsterInfo.resBody;
    dst->monsterInfo.resLight = src.monsterInfo.resLight;
    dst->monsterInfo.resDark = src.monsterInfo.resDark;
    dst->monsterInfo.resPhysical = src.monsterInfo.resPhysical;
    dst->monsterInfo.specialAbilityType = static_cast<MonsterSpecialAbility>(src.monsterInfo.specialAbilityType);
    dst->monsterInfo.specialAbilityDamageDiceRolls = src.monsterInfo.specialAbilityDamageDiceRolls;
    dst->monsterInfo.specialAbilityDamageDiceSides = src.monsterInfo.specialAbilityDamageDiceSides;
    dst->monsterInfo.specialAbilityDamageDiceBonus = src.monsterInfo.specialAbilityDamageDiceBonus;
    dst->monsterInfo.numCharactersAttackedPerSpecialAbility = src.monsterInfo.numCharactersAttackedPerSpecialAbility;
    dst->monsterInfo.id = static_cast<MonsterId>(src.monsterInfo.id);
    dst->monsterInfo.bloodSplatOnDeath = src.monsterInfo.bloodSplatOnDeath;
    reconstruct(src.monsterInfo.spell1SkillMastery, &dst->monsterInfo.spell1SkillMastery);
    reconstruct(src.monsterInfo.spell2SkillMastery, &dst->monsterInfo.spell2SkillMastery);
    dst->monsterInfo.field_3C_some_special_attack = src.monsterInfo.field_3C_some_special_attack;
    dst->monsterInfo.field_3E = src.monsterInfo.field_3E;
    dst->monsterInfo.hp = src.monsterInfo.hp;
    dst->monsterInfo.ac = src.monsterInfo.ac;
    dst->monsterInfo.exp = src.monsterInfo.exp;
    dst->monsterInfo.baseSpeed = src.monsterInfo.baseSpeed;
    dst->monsterInfo.recoveryTime = Duration::fromTicks(src.monsterInfo.recoveryTime);
    dst->monsterInfo.attackPreferences = static_cast<MonsterAttackPreferences>(src.monsterInfo.attackPreferences);
    dst->monsterId = static_cast<MonsterId>(src.monsterId);
    dst->radius = src.radius;
    dst->height = src.height;
    dst->moveSpeed = src.moveSpeed;
    reconstruct(src.pos, &dst->pos);
    reconstruct(src.velocity, &dst->velocity);
    dst->yawAngle = src.yawAngle;
    dst->pitchAngle = src.pitchAngle;
    dst->sectorId = src.sectorId;
    dst->currentActionLength = Duration::fromTicks(src.currentActionLength);
    reconstruct(src.initialPosition, &dst->initialPosition);
    reconstruct(src.guardingPosition, &dst->guardingPosition);
    dst->tetherDistance = src.tetherDistance;
    dst->aiState = static_cast<AIState>(src.aiState);
    dst->currentActionAnimation = static_cast<ActorAnimation>(src.currentActionAnimation);
    dst->carriedItemId = static_cast<ItemId>(src.carriedItemId);
    dst->currentActionTime = Duration::fromTicks(src.currentActionTime);

    reconstruct(src.spriteIds, &dst->spriteIds);
    reconstruct(src.soundSampleIds, &dst->soundSampleIds, tags::cast<uint16_t, SoundId>);
    reconstruct(src.buffs, &dst->buffs);
    reconstruct(src.items, &dst->items);

    dst->group = src.group;
    dst->ally = static_cast<MonsterType>(src.ally);

    reconstruct(src.scheduledJobs, &dst->scheduledJobs);

    dst->summonerId = Pid::fromPacked(src.summonerId);
    dst->lastCharacterIdToHit = Pid::fromPacked(src.lastCharacterIdToHit);
    dst->uniqueNameIndex = src.uniqueNameIndex;
}

void snapshot(const BLVDoor &src, BLVDoor_MM7 *dst) {
    memzero(dst);

    dst->attributes = std::to_underlying(src.attributes);
    dst->doorId = src.doorId;
    dst->timeSinceTriggered = src.timeSinceTriggered.ticks();
    dst->direction = src.direction.toFixpoint();
    dst->moveLength = src.moveLength;
    dst->openSpeed = src.openSpeed;
    dst->closeSpeed = src.closeSpeed;
    dst->numVertices = src.numVertices;
    dst->numFaces = src.numFaces;
    dst->numSectors = src.numSectors;
    dst->numOffsets = src.numOffsets;
    dst->state = std::to_underlying(src.state);
}

void reconstruct(const BLVDoor_MM7 &src, BLVDoor *dst) {
    dst->attributes = static_cast<DoorAttributes>(src.attributes);
    dst->doorId = src.doorId;
    dst->timeSinceTriggered = Duration::fromTicks(src.timeSinceTriggered);
    dst->direction = src.direction.toFloatFromFixpoint();
    dst->moveLength = src.moveLength;
    dst->openSpeed = src.openSpeed;
    dst->closeSpeed = src.closeSpeed;
    dst->numVertices = src.numVertices;
    dst->numFaces = src.numFaces;
    dst->numSectors = src.numSectors;
    dst->numOffsets = src.numOffsets;
    dst->state = static_cast<DoorState>(src.state);
}

void snapshot(const BLVSector &src, BLVSector_MM7 *dst) {
    memzero(dst);

    dst->flags = src.flags;
    dst->numFloors = src.floorIds.size();
    dst->numWalls = src.wallIds.size();
    dst->numCeilings = src.ceilingIds.size();
    dst->numPortals = src.portalIds.size();
    dst->numFaces = src.faceIds.size();
    dst->numNonBspFaces = src.nonBspFaceIds.size();
    dst->numDecorations = src.decorationIds.size();
    dst->numLights = src.lightIds.size();
    dst->minAmbientLightLevel = src.minAmbientLightLevel;
    dst->firstBspNode = src.firstBspNode;
    snapshot(src.boundingBox, &dst->boundingBox);
}

void reconstruct(const BLVSector_MM7 &src, BLVSector *dst) {
    dst->flags = src.flags;
    // Spans (floorIds, wallIds, etc.) are set up in CompositeSnapshots.cpp after sectorData is reconstructed.
    dst->minAmbientLightLevel = src.minAmbientLightLevel;
    dst->firstBspNode = src.firstBspNode;
    reconstruct(src.boundingBox, &dst->boundingBox);
}

void reconstruct(const ODMFace_MM7 &src, ODMFace *dst) {
    reconstruct(src.facePlane, &dst->facePlane);
    dst->zCalc.init(dst->facePlane);
    dst->attributes = FaceAttributes(src.attributes);
    dst->vertexIds = src.vertexIds;
    dst->textureUs = src.textureUs;
    dst->textureVs = src.textureVs;
    dst->texture = nullptr;
    dst->animationId = 0;
    dst->textureDeltaU = src.textureDeltaU;
    dst->textureDeltaV = src.textureDeltaV;
    reconstruct(src.boundingBox, &dst->boundingBox);
    dst->cogNumber = src.cogNumber;
    dst->eventId = src.eventId;
    dst->numVertices = src.numVertices;
    dst->polygonType = static_cast<PolygonType>(src.polygonType);
}

void reconstruct(const SpawnPoint_MM7 &src, SpawnPoint *dst) {
    dst->vPosition = src.vPosition.toFloat();
    dst->uRadius = src.uRadius;
    dst->uKind = static_cast<ObjectType>(src.uKind);
    if (dst->uKind == OBJECT_Actor) {
        dst->uItemIndex = ITEM_TREASURE_LEVEL_INVALID;
        dst->uMonsterIndex = src.uIndex;
    } else {
        assert(dst->uKind == OBJECT_Sprite);
        dst->uItemIndex = static_cast<ItemTreasureLevel>(src.uIndex);
        dst->uMonsterIndex = 0;
    }
    dst->uAttributes = src.uAttributes;
    dst->uGroup = src.uGroup;
}

void snapshot(const SpriteObject &src, SpriteObject_MM7 *dst) {
    memzero(dst);

    dst->uType = std::to_underlying(src.uType);
    dst->uObjectDescID = src.uObjectDescID;
    dst->vPosition = src.vPosition.toInt();
    snapshot(src.vVelocity, &dst->vVelocity);
    dst->uFacing = src.uFacing;
    dst->uSoundID = src.uSoundID;
    dst->uAttributes = std::to_underlying(src.uAttributes);
    dst->uSectorID = src.uSectorID;
    dst->uTimeSinceCreated = src.timeSinceCreated.ticks();
    dst->tempLifetime = src.tempLifetime.ticks();
    dst->field_22_glow_radius_multiplier = src.field_22_glow_radius_multiplier;
    snapshot(src.containing_item, &dst->containing_item, tags::context(ITEM_SLOT_INVALID));
    dst->uSpellID = std::to_underlying(src.uSpellID);
    dst->spell_level = src.spell_level;
    dst->spell_skill = std::to_underlying(src.spell_skill);
    dst->field_54 = src.field_54;
    dst->spell_caster_pid = src.spell_caster_pid.packed();
    dst->spell_target_pid = src.spell_target_pid.packed();
    dst->field_60_distance_related_prolly_lod = src.field_60_distance_related_prolly_lod;
    dst->spellCasterAbility = std::to_underlying(src.spellCasterAbility);
    dst->initialPosition = src.initialPosition.toInt();
}

void reconstruct(const SpriteObject_MM7 &src, SpriteObject *dst) {
    dst->uType = static_cast<SpriteId>(src.uType);
    dst->uObjectDescID = src.uObjectDescID;
    dst->vPosition = src.vPosition.toFloat();
    reconstruct(src.vVelocity, &dst->vVelocity);
    dst->uFacing = src.uFacing;
    dst->uSoundID = src.uSoundID;
    dst->uAttributes = SpriteAttributes(src.uAttributes);
    dst->uSectorID = src.uSectorID;
    dst->timeSinceCreated = Duration::fromTicks(src.uTimeSinceCreated);
    dst->tempLifetime = Duration::fromTicks(src.tempLifetime);
    dst->field_22_glow_radius_multiplier = src.field_22_glow_radius_multiplier;
    reconstruct(src.containing_item, &dst->containing_item);
    dst->uSpellID = static_cast<SpellId>(src.uSpellID);
    dst->spell_level = src.spell_level;
    dst->spell_skill = static_cast<Mastery>(src.spell_skill);
    dst->field_54 = src.field_54;
    dst->spell_caster_pid = Pid::fromPacked(src.spell_caster_pid);
    dst->spell_target_pid = Pid::fromPacked(src.spell_target_pid);
    dst->field_60_distance_related_prolly_lod = src.field_60_distance_related_prolly_lod;
    dst->spellCasterAbility = static_cast<ActorAbility>(src.spellCasterAbility);
    dst->initialPosition = src.initialPosition.toFloat();
}

void reconstruct(const DecorationDesc_MM6 &src, DecorationDesc *dst) {
    reconstruct(src.internalName, &dst->internalName);
    reconstruct(src.hint, &dst->hint);
    dst->uType = src.uType;
    dst->uDecorationHeight = src.uDecorationHeight;
    dst->uRadius = src.uRadius;
    dst->uLightRadius = src.uLightRadius;
    dst->uSpriteID = src.uSpriteID;
    dst->uFlags = DecorationDescFlags(src.uFlags);
    dst->uSoundID = static_cast<SoundId>(src.uSoundID);

    dst->uColoredLight.r = 255;
    dst->uColoredLight.g = 255;
    dst->uColoredLight.b = 255;
    dst->uColoredLight.a = 255;
}

void reconstruct(const DecorationDesc_MM7 &src, DecorationDesc *dst) {
    reconstruct(static_cast<const DecorationDesc_MM6 &>(src), dst);

    dst->uColoredLight.r = src.uColoredLightRed;
    dst->uColoredLight.g = src.uColoredLightGreen;
    dst->uColoredLight.b = src.uColoredLightBlue;
    dst->uColoredLight.a = 255;
}

void snapshot(const Chest &src, Chest_MM7 *dst) {
    memzero(dst);

    dst->chestTypeId = src.chestTypeId;
    dst->flags = std::to_underlying(src.flags);
    snapshot(src.inventory, dst);
}

void reconstruct(const Chest_MM7 &src, Chest *dst, ContextTag<int> chestId) {
    dst->chestTypeId = src.chestTypeId;
    dst->flags = ChestFlags(src.flags);
    reconstruct(src, &dst->inventory, chestId);
}

void snapshot(const ChestInventory &src, Chest_MM7 *dst) {
    for (size_t i = 0; i < 140; i++)
        snapshot(src._records[i].item, &dst->items[i], tags::context(ITEM_SLOT_INVALID));
    for (size_t i = 0; i < 140; i++)
        dst->inventoryMatrix[i] = src._grid[i];
}

void reconstruct(const Chest_MM7 &src, ChestInventory *dst, ContextTag<int> chestId) {
    Sizei size = chestTable[src.chestTypeId].size;

    *dst = ChestInventory(size);

    std::array<bool, 140> processed = {{}};
    std::array<Item, 140> items;
    reconstruct(src.items, &items);

    // Serialized chest inventory can be terribly broken, so we just check pretty much everything there is to check,
    // and just log errors.

    int maxIndex = size.w * size.h - 1;
    for (int x = 0; x < size.w; x++) {
        for (int y = 0; y < size.h; y++) {
            int index = src.inventoryMatrix[x + y * size.w];
            if (index <= 0)
                continue;
            index--;

            if (index > maxIndex) {
                logger->warning("Invalid item reference in chest #{} item grid, itemId={}, index={}, pos=({},{})",
                                *chestId, std::to_underlying(items[index].itemId), index, x, y);
                continue;
            }

            if (items[index].itemId == ITEM_NULL) {
                logger->warning("Null item in chest #{}, itemId={}, index={}, pos=({},{})",
                                *chestId, std::to_underlying(items[index].itemId), index, x, y);
                continue;
            }

            if (processed[index]) {
                logger->warning("Duplicate item in chest #{}, itemId={}, index={}, pos=({},{})",
                                *chestId, std::to_underlying(items[index].itemId), index, x, y);
                continue;
            }

            if (dst->canAdd({x, y}, items[index])) {
                processed[index] = true;
                dst->addAt({x, y}, items[index], index); // We need to preserve item indices.
            }
        }
    }

    for (size_t index = 0; index < items.size(); index++)
        if (!processed[index] && items[index].itemId != ITEM_NULL)
            dst->stashAt(items[index], index); // We need to preserve item indices.
}

void reconstruct(const BLVLight_MM7 &src, BLVLight *dst) {
    reconstruct(src.vPosition, &dst->vPosition);
    dst->uRadius = src.uRadius;
    dst->uRed = src.uRed;
    dst->uGreen = src.uGreen;
    dst->uBlue = src.uBlue;
    dst->uType = src.uType;
    dst->uAtributes = src.uAtributes;
    dst->uBrightness = src.uBrightness;
}

void reconstruct(const OverlayDesc_MM7 &src, OverlayDesc *dst) {
    dst->uOverlayID = src.uOverlayID;
    dst->uOverlayType = src.uOverlayType;
    dst->uSpriteFramesetID = src.uSpriteFramesetID;
    dst->spriteFramesetGroup = src.spriteFramesetGroup;
}

void reconstruct(const PortraitFrameData_MM7 &src, PortraitFrameData *dst) {
    dst->portrait = static_cast<PortraitId>(src.portrait);
    dst->textureIndex = src.textureIndex;
    dst->frameLength = Duration::fromTicks(src.frameLength * 8);
    dst->animationLength = Duration::fromTicks(src.animationLength * 8);
    dst->flags = static_cast<FrameFlags>(src.flags);
}

void reconstruct(const LevelDecoration_MM7 &src, LevelDecoration *dst) {
    dst->uDecorationDescID = static_cast<DecorationId>(src.uDecorationDescID);
    dst->uFlags = LevelDecorationFlags(src.uFlags);
    dst->vPosition = src.vPosition.toFloat();
    dst->_yawAngle = (TrigLUT.uIntegerHalfPi * src.field_1A) / 90;
    // src.field_1A - actually yaw angle in degrees, used when _yawAngle is not set.
    if (src._yawAngle)
        dst->_yawAngle = src._yawAngle;
    dst->uCog = src.uCog;
    dst->uEventID = src.uEventID;
    dst->uTriggerRange = src.uTriggerRange;
    dst->eventVarId = src.eventVarId - 75; // Was changed because all current usages are without this 75 shift
}

void reconstruct(const BLVFaceExtra_MM7 &src, BLVFaceExtra *dst) {
    dst->face_id = src.face_id;
    dst->uAdditionalBitmapID = src.uAdditionalBitmapID;
    dst->sTextureDeltaU = src.sTextureDeltaU;
    dst->sTextureDeltaV = src.sTextureDeltaV;
    dst->sCogNumber = src.sCogNumber;
    dst->uEventID = src.uEventID;
}

void reconstruct(const BSPNode_MM7 &src, BSPNode *dst) {
    dst->uFront = src.uFront;
    dst->uBack = src.uBack;
    dst->uBSPFaceIDOffset = src.uBSPFaceIDOffset;
    dst->uNumBSPFaces = src.uNumBSPFaces;
}

void reconstruct(const BLVMapOutline_MM7 &src, BLVMapOutline *dst) {
    dst->uVertex1ID = src.uVertex1ID;
    dst->uVertex2ID = src.uVertex2ID;
    dst->uFace1ID = src.uFace1ID;
    dst->uFace2ID = src.uFace2ID;
    dst->sZ = src.sZ;
    dst->uFlags = src.uFlags;
}

void reconstruct(const ObjectDesc_MM6 &src, ObjectDesc *dst) {
    dst->uObjectID = static_cast<SpriteId>(src.uObjectID);
    dst->uRadius = src.uRadius;
    dst->uHeight = src.uHeight;
    dst->uFlags = ObjectDescFlags(src.uFlags);
    dst->uSpriteID = src.uSpriteID;
    dst->uLifetime = Duration::fromTicks(src.uLifetime);
    // Note: src.uParticleTrailColor16 is ignored.
    dst->uParticleTrailColor = Color(src.uParticleTrailColorR, src.uParticleTrailColorG, src.uParticleTrailColorB);
    dst->uSpeed = src.uSpeed;
}

void reconstruct(const ObjectDesc_MM7 &src, ObjectDesc *dst) {
    dst->uObjectID = static_cast<SpriteId>(src.uObjectID);
    dst->uRadius = src.uRadius;
    dst->uHeight = src.uHeight;
    dst->uFlags = ObjectDescFlags(src.uFlags);
    dst->uSpriteID = src.uSpriteID;
    dst->uLifetime = Duration::fromTicks(src.uLifetime);
    // Note: src.uParticleTrailColor32 is ignored.
    dst->uParticleTrailColor = Color(src.uParticleTrailColorR, src.uParticleTrailColorG, src.uParticleTrailColorB);
    dst->uSpeed = src.uSpeed;
}

void snapshot(const LocationTime &src, LocationTime_MM7 *dst) {
    memzero(dst);

    snapshot(src.last_visit, &dst->last_visit);
    snapshot(src.sky_texture_name, &dst->sky_texture_name);
    dst->day_attrib = std::to_underlying(src.day_attrib);
    dst->day_fogrange_1 = src.day_fogrange_1;
    dst->day_fogrange_2 = src.day_fogrange_2;
}

void reconstruct(const LocationTime_MM7 &src, LocationTime *dst) {
    reconstruct(src.last_visit, &dst->last_visit);
    reconstruct(src.sky_texture_name, &dst->sky_texture_name);
    dst->day_attrib = static_cast<MapWeatherFlags>(src.day_attrib);
    dst->day_fogrange_1 = src.day_fogrange_1;
    dst->day_fogrange_2 = src.day_fogrange_2;
}

void reconstruct(const SoundInfo_MM6 &src, SoundInfo *dst) {
    reconstruct(src.name, &dst->name);
    dst->soundId = static_cast<SoundId>(src.soundId);
    dst->type = static_cast<SoundType>(src.type);
    dst->flags = static_cast<SoundFlags>(src.flags);
}

void reconstruct(const SoundInfo_MM7 &src, SoundInfo *dst) {
    reconstruct(static_cast<const SoundInfo_MM6 &>(src), dst);
}

void snapshot(const LocationInfo &src, LocationInfo_MM7 *dst) {
    memzero(dst);

    dst->respawnCount = src.respawnCount;
    dst->lastRespawnDay = src.lastRespawnDay;
    dst->reputation = src.reputation;
    dst->alertStatus = src.alertStatus;
}

void reconstruct(const LocationInfo_MM7 &src, LocationInfo *dst) {
    dst->respawnCount = src.respawnCount;
    dst->lastRespawnDay = src.lastRespawnDay;
    dst->reputation = src.reputation;
    dst->alertStatus = src.alertStatus;
}

void snapshot(const PersistentVariables &src, PersistentVariables_MM7 *dst) {
    memzero(dst);

    dst->mapVars = src.mapVars;
    dst->decorVars = src.decorVars;
}

void reconstruct(const PersistentVariables_MM7 &src, PersistentVariables *dst) {
    dst->mapVars = src.mapVars;
    dst->decorVars = src.decorVars;
}

void snapshot(const SaveGameHeader &src, SaveGameHeader_MM7 *dst) {
    memzero(dst);

    snapshot(src.name, &dst->name);
    snapshot(src.locationName, &dst->locationName);
    snapshot(src.playingTime, &dst->playingTime);
}

void reconstruct(const SaveGameHeader_MM7 &src, SaveGameHeader *dst) {
    reconstruct(src.name, &dst->name);
    reconstruct(src.locationName, &dst->locationName);
    reconstruct(src.playingTime, &dst->playingTime);
    // field_30 is ignored.
}
